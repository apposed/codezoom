<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>codezoom</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cytoscape/3.28.1/cytoscape.min.js"></script>
    <!-- Layout extensions -->
    <!-- dagre layout -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dagre/0.8.5/dagre.min.js"></script>
    <script src="https://unpkg.com/cytoscape-dagre@2.2.2/cytoscape-dagre.js"></script>
    <!-- fcose layout -->
    <script src="https://unpkg.com/layout-base@2.0.1/layout-base.js"></script>
    <script src="https://unpkg.com/cose-base@2.2.0/cose-base.js"></script>
    <script src="https://unpkg.com/cytoscape-fcose@2.2.0/cytoscape-fcose.js"></script>
    <!-- tidytree layout -->
    <script src="https://unpkg.com/cytoscape-tidytree@0.2.1/dist/cytoscape-tidytree.min.js"></script>
    <style>
        :root {
            /* Light theme (default) */
            --bg-primary: #f5f5f5;
            --bg-secondary: white;
            --text-primary: #222222;
            --text-secondary: #666;
            --text-tertiary: #333;
            --border-color: #ddd;
            --border-color-secondary: #ccc;
            --button-bg: #2c3e50;
            --button-bg-hover: #34495e;
            --button-bg-disabled: #bdc3c7;
            --info-bg: #e8f4f8;
            --info-border: #3498db;
            --breadcrumb-link: #2c3e50;
            --breadcrumb-link-hover: #34495e;
            --shadow-color: rgba(0,0,0,0.1);
        }

        body.dark-theme {
            /* Dark theme overrides */
            --bg-primary: #1e1e1e;
            --bg-secondary: #2d2d2d;
            --text-primary: #e0e0e0;
            --text-secondary: #aaa;
            --text-tertiary: #ccc;
            --border-color: #444;
            --border-color-secondary: #555;
            --button-bg: #4a5568;
            --button-bg-hover: #5a6778;
            --button-bg-disabled: #2d3748;
            --info-bg: #2a3f5f;
            --info-border: #4a9eff;
            --breadcrumb-link: #4a9eff;
            --breadcrumb-link-hover: #6bb0ff;
            --shadow-color: rgba(0,0,0,0.3);
        }

        body.high-contrast-theme {
            /* High contrast theme for accessibility */
            --bg-primary: #ffffff;
            --bg-secondary: #ffffff;
            --text-primary: #000000;
            --text-secondary: #000000;
            --text-tertiary: #000000;
            --border-color: #000000;
            --border-color-secondary: #333333;
            --button-bg: #000000;
            --button-bg-hover: #333333;
            --button-bg-disabled: #999999;
            --info-bg: #ffff99;
            --info-border: #000000;
            --breadcrumb-link: #0000cc;
            --breadcrumb-link-hover: #0000ff;
            --shadow-color: rgba(0,0,0,0.3);
        }

        body.dracula-theme {
            /* Official Dracula theme colors */
            --bg-primary: #282a36;
            --bg-secondary: #282a36;
            --text-primary: #f8f8f2;
            --text-secondary: #6272a4;
            --text-tertiary: #f8f8f2;
            --border-color: #44475a;
            --border-color-secondary: #6272a4;
            --button-bg: #6272a4;
            --button-bg-hover: #bd93f9;
            --button-bg-disabled: #44475a;
            --info-bg: #44475a;
            --info-border: #bd93f9;
            --breadcrumb-link: #8be9fd;
            --breadcrumb-link-hover: #ff79c6;
            --shadow-color: rgba(0,0,0,0.5);
        }

        body.nord-theme {
            /* Nord theme - Arctic, north-bluish color palette */
            --bg-primary: #2e3440;
            --bg-secondary: #3b4252;
            --text-primary: #eceff4;
            --text-secondary: #d8dee9;
            --text-tertiary: #e5e9f0;
            --border-color: #4c566a;
            --border-color-secondary: #434c5e;
            --button-bg: #5e81ac;
            --button-bg-hover: #81a1c1;
            --button-bg-disabled: #434c5e;
            --info-bg: #3b4252;
            --info-border: #88c0d0;
            --breadcrumb-link: #88c0d0;
            --breadcrumb-link-hover: #8fbcbb;
            --shadow-color: rgba(0,0,0,0.4);
        }

        body.solarized-dark-theme {
            /* Solarized Dark - Precision colors by Ethan Schoonover */
            --bg-primary: #002b36;
            --bg-secondary: #073642;
            --text-primary: #839496;
            --text-secondary: #586e75;
            --text-tertiary: #93a1a1;
            --border-color: #073642;
            --border-color-secondary: #586e75;
            --button-bg: #268bd2;
            --button-bg-hover: #2aa198;
            --button-bg-disabled: #073642;
            --info-bg: #073642;
            --info-border: #268bd2;
            --breadcrumb-link: #268bd2;
            --breadcrumb-link-hover: #2aa198;
            --shadow-color: rgba(0,0,0,0.5);
        }

        body.solarized-light-theme {
            /* Solarized Light - Precision colors by Ethan Schoonover */
            --bg-primary: #fdf6e3;
            --bg-secondary: #eee8d5;
            --text-primary: #657b83;
            --text-secondary: #93a1a1;
            --text-tertiary: #586e75;
            --border-color: #93a1a1;
            --border-color-secondary: #839496;
            --button-bg: #268bd2;
            --button-bg-hover: #2aa198;
            --button-bg-disabled: #93a1a1;
            --info-bg: #eee8d5;
            --info-border: #268bd2;
            --breadcrumb-link: #268bd2;
            --breadcrumb-link-hover: #2aa198;
            --shadow-color: rgba(0,0,0,0.1);
        }

        body.monokai-theme {
            /* Monokai - Classic TextMate theme */
            --bg-primary: #272822;
            --bg-secondary: #272822;
            --text-primary: #f8f8f2;
            --text-secondary: #75715e;
            --text-tertiary: #f8f8f2;
            --border-color: #49483e;
            --border-color-secondary: #75715e;
            --button-bg: #66d9ef;
            --button-bg-hover: #a6e22e;
            --button-bg-disabled: #49483e;
            --info-bg: #49483e;
            --info-border: #66d9ef;
            --breadcrumb-link: #66d9ef;
            --breadcrumb-link-hover: #a6e22e;
            --shadow-color: rgba(0,0,0,0.5);
        }

        body.one-dark-theme {
            /* One Dark - Atom's iconic theme */
            --bg-primary: #282c34;
            --bg-secondary: #21252b;
            --text-primary: #abb2bf;
            --text-secondary: #5c6370;
            --text-tertiary: #abb2bf;
            --border-color: #181a1f;
            --border-color-secondary: #3e4451;
            --button-bg: #61afef;
            --button-bg-hover: #98c379;
            --button-bg-disabled: #3e4451;
            --info-bg: #21252b;
            --info-border: #61afef;
            --breadcrumb-link: #61afef;
            --breadcrumb-link-hover: #56b6c2;
            --shadow-color: rgba(0,0,0,0.5);
        }

        body.gruvbox-theme {
            /* Gruvbox Dark - Retro groove colors */
            --bg-primary: #282828;
            --bg-secondary: #3c3836;
            --text-primary: #ebdbb2;
            --text-secondary: #a89984;
            --text-tertiary: #ebdbb2;
            --border-color: #504945;
            --border-color-secondary: #665c54;
            --button-bg: #458588;
            --button-bg-hover: #689d6a;
            --button-bg-disabled: #504945;
            --info-bg: #3c3836;
            --info-border: #458588;
            --breadcrumb-link: #83a598;
            --breadcrumb-link-hover: #8ec07c;
            --shadow-color: rgba(0,0,0,0.5);
        }

        body.tokyo-night-theme {
            /* Tokyo Night - Clean, elegant dark theme */
            --bg-primary: #1a1b26;
            --bg-secondary: #24283b;
            --text-primary: #c0caf5;
            --text-secondary: #565f89;
            --text-tertiary: #c0caf5;
            --border-color: #414868;
            --border-color-secondary: #565f89;
            --button-bg: #7aa2f7;
            --button-bg-hover: #7dcfff;
            --button-bg-disabled: #414868;
            --info-bg: #24283b;
            --info-border: #7aa2f7;
            --breadcrumb-link: #7aa2f7;
            --breadcrumb-link-hover: #7dcfff;
            --shadow-color: rgba(0,0,0,0.5);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background: var(--bg-primary);
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        #sidebar {
            width: 200px;
            min-width: 200px;
            max-width: 600px;
            background: var(--bg-secondary);
            display: flex;
            flex-direction: column;
            overflow-y: overlay;
            position: relative;
        }

        #resize-handle {
            position: absolute;
            right: 0;
            top: 0;
            bottom: 0;
            width: 8px;
            cursor: col-resize;
            background: transparent;
            z-index: 1000;
            transition: background 0.2s;
        }

        #resize-handle:hover,
        #resize-handle.dragging {
            background: var(--info-border);
            opacity: 0.5;
        }

        #main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        #controls {
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        #controls h1 {
            font-size: 18px;
            margin-bottom: 8px;
            color: var(--text-primary);
        }

        .control-row {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .control-row-horizontal {
            display: flex;
            gap: 4px;
            align-items: flex-start;
        }

        .layout-toolbar {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
        }

        .layout-toolbar button {
            width: 36px;
            height: 36px;
            padding: 4px;
            font-size: 18px;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            /* Add shadow to emojis for better visibility on all backgrounds */
            text-shadow: 0 0 3px rgba(255, 255, 255, 0.8),
                         0 0 3px rgba(0, 0, 0, 0.5);
        }

        .layout-toolbar button.has-cycle-indicator {
            padding-top: 6px;
        }

        .cycle-indicator {
            position: absolute;
            top: 2px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 1px;
        }

        .cycle-indicator span {
            width: 4px;
            height: 4px;
            background: #f1c40f;
            opacity: 0.35;
        }

        .cycle-indicator span.active {
            opacity: 1;
        }

        p {
            color: var(--text-secondary);
            font-size: 12px;
            line-height: 1.0;
        }

        button {
            padding: 6px;
            background: var(--button-bg);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 20px;
            min-width: 0;
        }

        button.small {
            font-size: 16px;
            padding: 2px 5px;
        }

        button:hover {
            background: var(--button-bg-hover);
        }

        button:disabled {
            background: var(--button-bg-disabled);
            cursor: not-allowed;
        }

        /* Right-click context menu */
        #context-menu {
            display: none;
            position: fixed;
            z-index: 1000;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            box-shadow: 0 2px 8px var(--shadow-color);
            min-width: 140px;
            overflow: hidden;
        }

        .ctx-item {
            padding: 8px 14px;
            cursor: pointer;
            color: var(--text-primary);
            font-size: 13px;
            white-space: nowrap;
        }

        .ctx-item:hover {
            background: var(--button-bg);
            color: white;
        }

        /* Help modal */
        #help-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }
        #help-overlay.visible {
            display: flex;
        }
        #help-modal {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            box-shadow: 0 4px 24px var(--shadow-color);
            padding: 20px 24px;
            max-width: 520px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            color: var(--text-primary);
            font-size: 13px;
        }
        #help-modal h2 {
            margin: 0 0 16px;
            font-size: 16px;
            color: var(--text-primary);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #help-modal h2 button {
            font-size: 14px;
            padding: 2px 8px;
            min-width: 0;
        }
        #help-modal h3 {
            margin: 14px 0 6px;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-secondary);
        }
        #help-modal table {
            width: 100%;
            border-collapse: collapse;
        }
        #help-modal td {
            padding: 4px 6px;
            vertical-align: top;
        }
        #help-modal td:first-child {
            white-space: nowrap;
            font-family: monospace;
            font-size: 12px;
            background: var(--bg-primary);
            border-radius: 3px;
            padding: 3px 7px;
            width: 1%;
        }
        #help-modal tr + tr td {
            border-top: 1px solid var(--border-color);
        }

        #breadcrumb {
            font-size: 12px;
            color: var(--text-secondary);
            padding: 8px;
            background: var(--bg-primary);
            border-radius: 4px;
            word-wrap: break-word;
            flex: 1;
        }

        #breadcrumb a {
            color: var(--breadcrumb-link);
            cursor: pointer;
            text-decoration: underline;
        }

        #breadcrumb a:hover {
            color: var(--breadcrumb-link-hover);
        }

        #cy {
            flex: 1;
            background: var(--bg-secondary);
        }

        .section-label {
            color: var(--text-secondary);
            font-size: 12px;
            font-weight: bold;
            font-variant: small-caps;
            padding-top: 6px;
            border-bottom: 1px solid var(--text-secondary);
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 8px;
            flex: 1;
            min-width: 0;
        }

        .slider-container input[type="range"] {
            flex: 1;
            min-width: 0;
        }

        .slider-container span {
            color: var(--text-secondary);
            font-size: 12px;
            min-width: 20px;
            text-align: right;
        }

        .checkbox-label {
            color: var(--text-secondary);
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 6px;
            cursor: pointer;
        }

        .checkbox-label input[type="checkbox"] {
            cursor: pointer;
        }

        #themeSelector {
            padding: 8px 10px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            font-size: 13px;
            cursor: pointer;
            background: var(--bg-primary);
            color: var(--text-primary);
            width: 100%;
        }
    </style>
</head>
<body>
    <div id="sidebar">
        <div id="resize-handle"></div>
        <div id="controls">
            <!-- Header -->
            <h1 id="titleText"></h1>

            <!-- Navigation -->
            <div class="control-row">
                <div class="section-label">Navigation</div>
                <p>Double-click node to zoom in.</p>
                <p>Click breadcrumb to go back.</p>
                <div id="breadcrumb" title="Breadcrumb trail"></div>
                <div class="control-row-horizontal">
                    <button id="resetBtn" onclick="reset()" title="Reset to top">&#x1f3e0;</button> <!-- House -->
                    <button id="backBtn" onclick="goUp()" title="Go up one level">&#x2b06;&#xfe0f;</button> <!-- Up Arrow -->
                    <button onclick="showHelp()" title="Help (? or F1)">&#x2753;</button> <!-- Question Mark -->
                </div>
            </div>

            <!-- Layout -->
            <div class="control-row">
                <div class="section-label">Layout</div>
                <div class="layout-toolbar">
                    <button onclick="applyLayout('cose')" title="Force-directed (CoSE)">&#x2b50;</button> <!-- Star -->
                    <button onclick="applyLayout('fcose')" title="Fast Force-directed (fCoSE) - Recommended">&#x26a1;</button> <!-- Lightning -->
                    <button id="btn-dagre-down" onclick="applyLayout('dagre', {'ranker': dagre_ranker()})" title="Hierarchy Downward (Dagre)">&#x2935;&#xfe0f;</button> <!-- Right Arrow Curving Down -->
                    <button id="btn-dagre-right" onclick="applyLayout('dagre', {'rankDir': 'LR', 'ranker': dagre_ranker()})" title="Hierarchy Rightward (Dagre)">&#x21aa;&#xfe0f;</button> <!-- Left Arrow Curving Right -->
                    <button id="btn-breadthfirst" onclick="applyLayout('breadthfirst', breadthfirst_options())" title="Tree (top-down)">&#x1f332;</button> <!-- Evergreen Tree -->
                    <button id="btn-tidytree" onclick="applyLayout('tidytree', tidytree_options())" title="Tidy tree layout">&#x1f334;</button> <!-- Palm Tree -->
                    <button onclick="applyLayout('breadthfirst', {'circle': true})" title="Radial Tree">&#x1f300;</button> <!-- Cyclone/Spiral -->
                    <button id="btn-concentric" onclick="applyLayout('concentric', concentric_options())" title="Concentric rings by depth">&#x1f3af;</button> <!-- Bullseye/Target -->
                    <button onclick="applyLayout('circle')" title="Simple circle">&#x2b55;</button> <!-- Hollow Red Circle -->
                    <button onclick="applyLayout('grid')" title="Grid layout">&#x2b1c;</button> <!-- White Large Square -->
                    <button onclick="applyLayout('random')" title="Random layout">&#x1f3b2;</button> <!-- Game Die -->
                </div>
            </div>

            <!-- Appearance -->
            <div class="control-row">
                <div class="section-label">Appearance</div>
                <div class="control-row-horizontal" title="Theme">
                    <div>&#x1f3a8;</div> <!-- Artist Palette -->
                    <select id="themeSelector" onchange="changeTheme(this.value)">
                        <option value="light">Light</option>
                        <option value="dark">Dark</option>
                        <option value="dracula">Dracula</option>
                        <option value="nord">Nord</option>
                        <option value="solarized-dark">Solarized Dark</option>
                        <option value="solarized-light">Solarized Light</option>
                        <option value="monokai">Monokai</option>
                        <option value="one-dark">One Dark</option>
                        <option value="gruvbox">Gruvbox</option>
                        <option value="tokyo-night">Tokyo Night</option>
                        <option value="high-contrast">High Contrast</option>
                    </select>
                </div>

                <div class="control-row-horizontal" title="Zoom Level">
                    <div>&#x1f50d;</div> <!-- Magnifying Glass Tilted Left -->
                    <div class="slider-container">
                        <input type="range" id="zoomSlider" min="10" max="300" value="100">
                        <span id="zoomValue">100%</span>
                    </div>
                    <button onclick="cy.fit()" class="small" title="Fit view">&#x26f6;</button> <!-- Square Four Corners -->
                </div>
                <div class="control-row-horizontal" title="Node Size">
                    <div>&#x1f7e0;</div> <!-- Orange Circle -->
                    <div class="slider-container">
                        <input type="range" id="sizeSlider" min="20" max="100" value="50">
                        <span id="sizeValue">50</span>
                    </div>
                </div>
                <div class="control-row-horizontal" title="Font Size">
                    <div style="color: var(--text-secondary); font-size: 20px; text-align: center; width: 1rem;">&#x1d413;</div> <!-- Mathematical Bold Capital T -->
                    <div class="slider-container">
                        <input type="range" id="fontSlider" min="8" max="40" value="12">
                        <span id="fontValue">12</span>
                    </div>
                </div>
            </div>

            <!-- Nodes and Edges -->
            <div class="control-row">
                <div class="control-row-horizontal">
                    <div style="margin-right: 10px">
                        <div class="section-label">Nodes</div>

                        <!-- Dependency visibility (shown only at top level) -->
                        <label id="vis-direct-label" class="checkbox-label" style="display: none;">
                            <input type="checkbox" id="vis-direct" checked>
                            <span>Direct</span>
                        </label>
                        <label id="vis-transitive-label" class="checkbox-label" style="display: none;">
                            <input type="checkbox" id="vis-transitive" checked>
                            <span>Transitive</span>
                        </label>

                        <!-- Code visibility (shown at package/class levels) -->
                        <label id="vis-public-label" class="checkbox-label" style="display: none;">
                            <input type="checkbox" id="vis-public" checked>
                            <span>Public</span>
                        </label>
                        <label id="vis-protected-label" class="checkbox-label" style="display: none;">
                            <input type="checkbox" id="vis-protected" checked>
                            <span>Protected</span>
                        </label>
                        <label id="vis-package-label" class="checkbox-label" style="display: none;">
                            <input type="checkbox" id="vis-package" checked>
                            <span>Package</span>
                        </label>
                        <label id="vis-private-label" class="checkbox-label" style="display: none;">
                            <input type="checkbox" id="vis-private" checked>
                            <span>Private</span>
                        </label>
                    </div>
                    <div>
                        <div class="section-label">Edges</div>
                        <label id="vis-inherits-label" class="checkbox-label" title="Structural 'is-a' relationship hierarchies">
                            <input type="checkbox" id="vis-inherits" checked>
                            <span>Inherits</span>
                        </label>
                        <label id="vis-uses-label" class="checkbox-label" title="Runtime dependencies (components/libraries), imports (packages/modules), usage (classes), calls (functions/methods)">
                            <input type="checkbox" id="vis-uses" checked>
                            <span>Uses</span>
                        </label>
                    </div>
                </div>
            </div>

            <!-- Display -->
            <div class="control-row">
                <div class="section-label">Display</div>
                <label class="checkbox-label">
                    <input type="checkbox" id="showHidden" onchange="toggleHiddenDisplay(this.checked)">
                    <span>&#x1fae3; Peek at hidden</span> <!-- Face With Peeking Eye -->
                </label>
                <div class="layout-toolbar">
                    <button id="hideShowBtn" onclick="toggleHideShowSelected()" title="Hide selected nodes" disabled>&#x1f441;&#xfe0f;</button> <!-- Eye -->
                    <button id="highlightBtn" onclick="toggleHighlightSelected()" title="Highlight selected nodes" disabled>&#x2728;</button> <!-- Sparkles -->
                    <button id="expandBtn" onclick="toggleExpandSelected()" title="Expand selected nodes" disabled>&#x229e;</button> <!-- Squared Plus -->
                </div>
            </div>
        </div>
    </div>

    <div id="main-content">
        <div id="cy"></div>
    </div>

    <!-- Right-click context menu -->
    <div id="context-menu">
        <div class="ctx-item" id="ctx-expand" onclick="ctxExpand()">Expand</div>
        <div class="ctx-item" id="ctx-drill-in" onclick="ctxDrillIn()">Drill In</div>
        <div class="ctx-item" id="ctx-hide-show" onclick="ctxHideShow()">Hide</div>
        <div class="ctx-item" id="ctx-highlight" onclick="ctxHighlight()">Highlight</div>
    </div>

    <!-- Help modal -->
    <div id="help-overlay" onclick="hideHelp()">
        <div id="help-modal" onclick="event.stopPropagation()">
            <h2>Keyboard &amp; Mouse Reference <button onclick="hideHelp()">‚úï</button></h2>

            <h3>Keyboard</h3>
            <table>
                <tr><td>? / F1</td><td>Show this help</td></tr>
                <tr><td>Esc</td><td>Deselect all nodes; close menus</td></tr>
                <tr><td>Enter</td><td>Drill into selected node</td></tr>
                <tr><td>Ctrl + A</td><td>Select all visible nodes</td></tr>
                <tr><td>Del</td><td>Hide / show selected nodes</td></tr>
                <tr><td>H</td><td>Toggle highlight on selected nodes</td></tr>
                <tr><td>E</td><td>Expand / collapse selected nodes</td></tr>
                <tr><td>F</td><td>Fit graph to viewport</td></tr>
                <tr><td>Home</td><td>Reset to top-level view</td></tr>
            </table>

            <h3>Mouse ‚Äî Nodes</h3>
            <table>
                <tr><td>Click</td><td>Select single node</td></tr>
                <tr><td>Drag</td><td>Move selected node(s)</td></tr>
                <tr><td>Double-click</td><td>Drill into node (zoom in one level)</td></tr>
                <tr><td>Right-click</td><td>Open context menu (Expand, Drill In, Hide, Highlight)</td></tr>
                <tr><td>Ctrl + click</td><td>Add clicked node to selection</td></tr>
                <tr><td>Shift + Drag</td><td>Select nodes inside rectangle</td></tr>
                <tr><td>Alt + Drag</td><td>Move selected node(s) and all descendants together</td></tr>
            </table>

            <h3>Mouse ‚Äî Canvas</h3>
            <table>
                <tr><td>Scroll wheel</td><td>Zoom in / out</td></tr>
                <tr><td>Drag (background)</td><td>Pan the canvas</td></tr>
                <tr><td>Click (background)</td><td>Deselect all nodes</td></tr>
            </table>

            <h3>Navigation</h3>
            <table>
                <tr><td>üè†</td><td>Reset to top-level view</td></tr>
                <tr><td>‚¨ÜÔ∏è</td><td>Go up one level</td></tr>
                <tr><td>Breadcrumb</td><td>Click any crumb to jump to that level</td></tr>
            </table>
        </div>
    </div>

    <script>
        // All data injected as a single JSON blob
        const data = $DATA_JSON;

        const hierarchy = data.hierarchy;
        const functionData = data.functionData;
        const pythonDeps = data.external_deps;
        const pythonDepsDirect = data.external_deps_direct;
        const pythonDepsGraph = data.external_deps_graph;
        const moduleDirectDeps = data.module_direct_deps || {};
        const ROOT_IDS = data.root_node_ids;
        const MULTI_ROOT = ROOT_IDS.length > 1;
        const TOP_LEVEL = '__codezoom_top__';
        let expandedNodes = new Set(); // IDs of package nodes expanded as compound containers

        // Set page title
        document.getElementById('titleText').textContent = 'codezoom | ' + data.project_name;
        document.title = data.project_name + ' ‚Äî codezoom';

        // Layout configuration
        var dagre_ranker_index = 0;
        function dagre_ranker() {
            // Cycle through dagre ranker values.
            // Note: 'network-simplex' seems equivalent to 'tight-tree' in all my tests.
            const rankers = ['longest-path', 'tight-tree'];
            const result = rankers[dagre_ranker_index++ % rankers.length];
            updateCycleIndicator('btn-dagre-down', dagre_ranker_index, rankers.length);
            updateCycleIndicator('btn-dagre-right', dagre_ranker_index, rankers.length);
            return result;
        }
        var breadthfirst_index = 0;
        function breadthfirst_options() {
            const options = [
                {grid: false, maximal: false},
                {grid: true, maximal: false},
                {grid: false, maximal: true},
                {grid: true, maximal: true},
            ];
            const result = options[breadthfirst_index++ % options.length];
            updateCycleIndicator('btn-breadthfirst', breadthfirst_index, options.length);
            return result;
        }
        var tidytree_index = 0;
        function tidytree_options() {
            const options = [
                {direction: 'TB'},
                {direction: 'LR'},
            ];
            const result = options[tidytree_index++ % options.length];
            updateCycleIndicator('btn-tidytree', tidytree_index, options.length);
            return result;
        }
        var concentric_index = 0;
        function concentric_options() {
            // Different metrics for determining which ring a node goes on
            // HIGHER values ‚Üí center (Cytoscape concentric behavior)
            // All metrics prioritize root node at center (return high value for root)
            const metricDegree = node => {
                if (node.data('nodeType') === 'root') return 10000; // Root gets highest value
                return node.degree(); // High degree ‚Üí center
            };
            const metricIndegree = node => {
                if (node.data('nodeType') === 'root') return 10000;
                return node.indegree(); // High indegree ‚Üí center
            };
            const metricOutdegree = node => {
                if (node.data('nodeType') === 'root') return 10000;
                return node.outdegree(); // High outdegree ‚Üí center
            };
            const metricType = node => {
                // Invert the order: higher values toward center
                const typeOrder = {'root': 10000, 'clickable': 700, 'regular': 600,
                                 'class': 500, 'function': 400, 'method': 300,
                                 'external-direct': 200, 'external-indirect': 100};
                const nodeType = node.data('nodeType');
                return typeOrder[nodeType] !== undefined ? typeOrder[nodeType] : 0;
            };

            // Level width functions - only use values that differ significantly
            const lwSingle = () => 1;
            const lwWide = nodes => Math.max(2, Math.ceil(nodes.length / 4));  // Wide spread
            const lwMedium = nodes => Math.max(2, Math.ceil(nodes.length / 8)); // Medium
            const lwTight = nodes => Math.max(2, Math.ceil(nodes.length / 16)); // Tight

            // Create visually distinct combinations
            const options = [
                // Single ring per level (classic concentric)
                {minNodeSpacing: 50, equidistant: false, levelWidth: lwSingle,
                 concentric: metricDegree, startAngle: Math.PI/2},

                // Wide spread, non-equidistant (organic feel)
                {minNodeSpacing: 50, equidistant: false, levelWidth: lwWide,
                 concentric: metricDegree, startAngle: Math.PI/2},

                // Medium spread, varied angles
                {minNodeSpacing: 50, equidistant: false, levelWidth: lwMedium,
                 concentric: metricIndegree, startAngle: 0},

                // Equidistant (geometric, requires low spacing)
                {minNodeSpacing: 10, equidistant: true, levelWidth: lwMedium,
                 concentric: metricDegree, startAngle: Math.PI/2},

                // Tight spread, type-based ordering
                {minNodeSpacing: 50, equidistant: false, levelWidth: lwTight,
                 concentric: metricType, startAngle: Math.PI/4},

                // Outdegree-based (sources toward center)
                {minNodeSpacing: 50, equidistant: false, levelWidth: lwMedium,
                 concentric: metricOutdegree, startAngle: -Math.PI/2}
            ];
            const result = options[concentric_index++ % options.length];
            updateCycleIndicator('btn-concentric', concentric_index, options.length);
            return result;
        }

        // Cycle indicator helpers
        function createCycleIndicator(buttonId, count) {
            const btn = document.getElementById(buttonId);
            if (!btn) return;
            btn.classList.add('has-cycle-indicator');
            const div = document.createElement('div');
            div.className = 'cycle-indicator';
            for (let i = 0; i < count; i++) {
                const span = document.createElement('span');
                if (i === 0) span.classList.add('active');
                div.appendChild(span);
            }
            btn.appendChild(div);
        }

        function updateCycleIndicator(buttonId, currentIndex, count) {
            const btn = document.getElementById(buttonId);
            if (!btn) return;
            const spans = btn.querySelectorAll('.cycle-indicator span');
            spans.forEach((s, i) => {
                s.classList.toggle('active', i === currentIndex % count);
            });
            const baseTitle = btn.title.replace(/\s*\(preset \d+ of \d+\)/, '');
            btn.title = baseTitle + ' (preset ' + ((currentIndex % count) + 1) + ' of ' + count + ')';
        }

        // Initialize cycle indicators
        createCycleIndicator('btn-dagre-down', 2);
        createCycleIndicator('btn-dagre-right', 2);
        createCycleIndicator('btn-breadthfirst', 4);
        createCycleIndicator('btn-tidytree', 2);
        createCycleIndicator('btn-concentric', 6);

        // Theme configuration
        const themes = {
            light: {
                nodeRoot: '#e74c3c',
                nodeRootText: '#ffffff',
                nodeClickable: '#f39c12',
                nodeClickableText: '#000000',
                nodeRegular: '#3498db',
                nodeRegularText: '#ffffff',
                nodeClass: '#9b59b6',
                nodeClassText: '#ffffff',
                nodeFunction: '#16a085',
                nodeFunctionText: '#ffffff',
                nodeMethod: '#e74c3c',
                nodeMethodText: '#ffffff',
                nodeExternalDirect: '#34495e',
                nodeExternalDirectText: '#ffffff',
                nodeExternalIndirect: '#95a5a6',
                nodeExternalIndirectText: '#000000',
                nodeHover: '#f1c40f',
                nodeHoverText: '#000000',
                edgeLine: '#95a5a6',
                edgeArrow: '#666',
                cyBackground: 'white',
                textOutlineDark: '#000000',   // Dark outline for light text
                textOutlineLight: '#ffffff'   // Light outline for dark text
            },
            dark: {
                nodeRoot: '#ff6b6b',
                nodeRootText: '#000000',
                nodeClickable: '#ffa500',
                nodeClickableText: '#000000',
                nodeRegular: '#4a9eff',
                nodeRegularText: '#000000',
                nodeClass: '#bd93f9',
                nodeClassText: '#000000',
                nodeFunction: '#50fa7b',
                nodeFunctionText: '#000000',
                nodeMethod: '#ff6b6b',
                nodeMethodText: '#000000',
                nodeExternalDirect: '#6272a4',
                nodeExternalDirectText: '#ffffff',
                nodeExternalIndirect: '#44475a',
                nodeExternalIndirectText: '#ffffff',
                nodeHover: '#f1fa8c',
                nodeHoverText: '#000000',
                edgeLine: '#6272a4',
                edgeArrow: '#888',
                cyBackground: '#1e1e1e',
                textOutlineDark: '#000000',
                textOutlineLight: '#ffffff'
            },
            'high-contrast': {
                nodeRoot: '#cc0000',
                nodeRootText: '#ffffff',
                nodeClickable: '#ff8800',
                nodeClickableText: '#000000',
                nodeRegular: '#0066cc',
                nodeRegularText: '#ffffff',
                nodeClass: '#7700cc',
                nodeClassText: '#ffffff',
                nodeFunction: '#008866',
                nodeFunctionText: '#ffffff',
                nodeMethod: '#cc0000',
                nodeMethodText: '#ffffff',
                nodeExternalDirect: '#000000',
                nodeExternalDirectText: '#ffffff',
                nodeExternalIndirect: '#666666',
                nodeExternalIndirectText: '#ffffff',
                nodeHover: '#ffff00',
                nodeHoverText: '#000000',
                edgeLine: '#666666',
                edgeArrow: '#333333',
                cyBackground: '#ffffff',
                textOutlineDark: '#000000',
                textOutlineLight: '#ffffff'
            },
            'dracula': {
                // Official Dracula color palette
                nodeRoot: '#ff5555',           // Dracula Red
                nodeRootText: '#282a36',       // Dracula Background (dark on light red)
                nodeClickable: '#ffb86c',      // Dracula Orange
                nodeClickableText: '#282a36',  // Dark text on orange
                nodeRegular: '#8be9fd',        // Dracula Cyan
                nodeRegularText: '#282a36',    // Dark text on cyan
                nodeClass: '#bd93f9',          // Dracula Purple
                nodeClassText: '#282a36',      // Dark text on purple
                nodeFunction: '#50fa7b',       // Dracula Green
                nodeFunctionText: '#282a36',   // Dark text on green
                nodeMethod: '#ff5555',         // Dracula Red
                nodeMethodText: '#282a36',     // Dark text on red
                nodeExternalDirect: '#6272a4', // Dracula Comment (blue-gray)
                nodeExternalDirectText: '#f8f8f2', // Light text on dark
                nodeExternalIndirect: '#44475a', // Dracula Current Line
                nodeExternalIndirectText: '#f8f8f2', // Light text on dark
                nodeHover: '#f1fa8c',          // Dracula Yellow
                nodeHoverText: '#282a36',      // Dark text on yellow
                edgeLine: '#6272a4',           // Dracula Comment
                edgeArrow: '#44475a',          // Dracula Current Line
                cyBackground: '#282a36',       // Dracula Background
                textOutlineDark: '#282a36',    // Dark outline (background color)
                textOutlineLight: '#f8f8f2'    // Light outline (foreground color)
            },
            'nord': {
                // Nord - Arctic, north-bluish color palette
                nodeRoot: '#bf616a',           // Nord Aurora Red
                nodeRootText: '#2e3440',       // Dark text on red
                nodeClickable: '#d08770',      // Nord Aurora Orange
                nodeClickableText: '#2e3440',  // Dark text on orange
                nodeRegular: '#5e81ac',        // Nord Frost Blue
                nodeRegularText: '#eceff4',    // Light text on blue
                nodeClass: '#b48ead',          // Nord Aurora Purple
                nodeClassText: '#2e3440',      // Dark text on purple
                nodeFunction: '#a3be8c',       // Nord Aurora Green
                nodeFunctionText: '#2e3440',   // Dark text on green
                nodeMethod: '#bf616a',         // Nord Aurora Red
                nodeMethodText: '#2e3440',     // Dark text on red
                nodeExternalDirect: '#4c566a', // Nord Polar Night
                nodeExternalDirectText: '#eceff4', // Light text on dark
                nodeExternalIndirect: '#3b4252', // Nord Polar Night
                nodeExternalIndirectText: '#eceff4', // Light text on dark
                nodeHover: '#ebcb8b',          // Nord Aurora Yellow
                nodeHoverText: '#2e3440',      // Dark text on yellow
                edgeLine: '#4c566a',           // Nord Polar Night
                edgeArrow: '#434c5e',          // Nord Polar Night
                cyBackground: '#2e3440',       // Nord Background
                textOutlineDark: '#2e3440',    // Dark outline
                textOutlineLight: '#eceff4'    // Light outline
            },
            'solarized-dark': {
                // Solarized Dark - Precision colors by Ethan Schoonover
                nodeRoot: '#dc322f',           // Solarized Red
                nodeRootText: '#fdf6e3',       // Light text on red
                nodeClickable: '#cb4b16',      // Solarized Orange
                nodeClickableText: '#fdf6e3',  // Light text on orange
                nodeRegular: '#268bd2',        // Solarized Blue
                nodeRegularText: '#fdf6e3',    // Light text on blue
                nodeClass: '#6c71c4',          // Solarized Violet
                nodeClassText: '#fdf6e3',      // Light text on violet
                nodeFunction: '#859900',       // Solarized Green
                nodeFunctionText: '#fdf6e3',   // Light text on green
                nodeMethod: '#dc322f',         // Solarized Red
                nodeMethodText: '#fdf6e3',     // Light text on red
                nodeExternalDirect: '#073642', // Solarized Base02
                nodeExternalDirectText: '#839496', // Medium text on dark
                nodeExternalIndirect: '#586e75', // Solarized Base01
                nodeExternalIndirectText: '#93a1a1', // Light text on medium
                nodeHover: '#b58900',          // Solarized Yellow
                nodeHoverText: '#002b36',      // Dark text on yellow
                edgeLine: '#586e75',           // Solarized Base01
                edgeArrow: '#073642',          // Solarized Base02
                cyBackground: '#002b36',       // Solarized Background
                textOutlineDark: '#002b36',    // Dark outline
                textOutlineLight: '#fdf6e3'    // Light outline
            },
            'solarized-light': {
                // Solarized Light - Precision colors by Ethan Schoonover
                nodeRoot: '#dc322f',           // Solarized Red
                nodeRootText: '#fdf6e3',       // Light text on red
                nodeClickable: '#cb4b16',      // Solarized Orange
                nodeClickableText: '#fdf6e3',  // Light text on orange
                nodeRegular: '#268bd2',        // Solarized Blue
                nodeRegularText: '#fdf6e3',    // Light text on blue
                nodeClass: '#6c71c4',          // Solarized Violet
                nodeClassText: '#fdf6e3',      // Light text on violet
                nodeFunction: '#859900',       // Solarized Green
                nodeFunctionText: '#fdf6e3',   // Light text on green
                nodeMethod: '#dc322f',         // Solarized Red
                nodeMethodText: '#fdf6e3',     // Light text on red
                nodeExternalDirect: '#93a1a1', // Solarized Base1
                nodeExternalDirectText: '#002b36', // Dark text on light
                nodeExternalIndirect: '#eee8d5', // Solarized Base2
                nodeExternalIndirectText: '#002b36', // Dark text on light
                nodeHover: '#b58900',          // Solarized Yellow
                nodeHoverText: '#002b36',      // Dark text on yellow
                edgeLine: '#93a1a1',           // Solarized Base1
                edgeArrow: '#839496',          // Solarized Base0
                cyBackground: '#fdf6e3',       // Solarized Background
                textOutlineDark: '#002b36',    // Dark outline
                textOutlineLight: '#fdf6e3'    // Light outline
            },
            'monokai': {
                // Monokai - Classic TextMate theme
                nodeRoot: '#f92672',           // Monokai Pink
                nodeRootText: '#272822',       // Dark text on pink
                nodeClickable: '#fd971f',      // Monokai Orange
                nodeClickableText: '#272822',  // Dark text on orange
                nodeRegular: '#66d9ef',        // Monokai Blue
                nodeRegularText: '#272822',    // Dark text on blue
                nodeClass: '#ae81ff',          // Monokai Purple
                nodeClassText: '#272822',      // Dark text on purple
                nodeFunction: '#a6e22e',       // Monokai Green
                nodeFunctionText: '#272822',   // Dark text on green
                nodeMethod: '#f92672',         // Monokai Pink
                nodeMethodText: '#272822',     // Dark text on pink
                nodeExternalDirect: '#49483e', // Monokai Dark Gray
                nodeExternalDirectText: '#f8f8f2', // Light text on dark
                nodeExternalIndirect: '#75715e', // Monokai Gray
                nodeExternalIndirectText: '#f8f8f2', // Light text on gray
                nodeHover: '#e6db74',          // Monokai Yellow
                nodeHoverText: '#272822',      // Dark text on yellow
                edgeLine: '#75715e',           // Monokai Gray
                edgeArrow: '#49483e',          // Monokai Dark Gray
                cyBackground: '#272822',       // Monokai Background
                textOutlineDark: '#272822',    // Dark outline
                textOutlineLight: '#f8f8f2'    // Light outline
            },
            'one-dark': {
                // One Dark - Atom's iconic theme
                nodeRoot: '#e06c75',           // One Dark Red
                nodeRootText: '#282c34',       // Dark text on red
                nodeClickable: '#d19a66',      // One Dark Orange
                nodeClickableText: '#282c34',  // Dark text on orange
                nodeRegular: '#61afef',        // One Dark Blue
                nodeRegularText: '#282c34',    // Dark text on blue
                nodeClass: '#c678dd',          // One Dark Purple
                nodeClassText: '#282c34',      // Dark text on purple
                nodeFunction: '#98c379',       // One Dark Green
                nodeFunctionText: '#282c34',   // Dark text on green
                nodeMethod: '#e06c75',         // One Dark Red
                nodeMethodText: '#282c34',     // Dark text on red
                nodeExternalDirect: '#3e4451', // One Dark Gray
                nodeExternalDirectText: '#abb2bf', // Light text on dark
                nodeExternalIndirect: '#21252b', // One Dark Darker
                nodeExternalIndirectText: '#abb2bf', // Light text on dark
                nodeHover: '#e5c07b',          // One Dark Yellow
                nodeHoverText: '#282c34',      // Dark text on yellow
                edgeLine: '#5c6370',           // One Dark Comment
                edgeArrow: '#3e4451',          // One Dark Gray
                cyBackground: '#282c34',       // One Dark Background
                textOutlineDark: '#282c34',    // Dark outline
                textOutlineLight: '#abb2bf'    // Light outline
            },
            'gruvbox': {
                // Gruvbox Dark - Retro groove colors
                nodeRoot: '#fb4934',           // Gruvbox Bright Red
                nodeRootText: '#282828',       // Dark text on red
                nodeClickable: '#fe8019',      // Gruvbox Bright Orange
                nodeClickableText: '#282828',  // Dark text on orange
                nodeRegular: '#83a598',        // Gruvbox Bright Blue
                nodeRegularText: '#282828',    // Dark text on blue
                nodeClass: '#d3869b',          // Gruvbox Bright Purple
                nodeClassText: '#282828',      // Dark text on purple
                nodeFunction: '#b8bb26',       // Gruvbox Bright Green
                nodeFunctionText: '#282828',   // Dark text on green
                nodeMethod: '#fb4934',         // Gruvbox Bright Red
                nodeMethodText: '#282828',     // Dark text on red
                nodeExternalDirect: '#504945', // Gruvbox Dark Gray
                nodeExternalDirectText: '#ebdbb2', // Light text on dark
                nodeExternalIndirect: '#3c3836', // Gruvbox Darker
                nodeExternalIndirectText: '#ebdbb2', // Light text on dark
                nodeHover: '#fabd2f',          // Gruvbox Bright Yellow
                nodeHoverText: '#282828',      // Dark text on yellow
                edgeLine: '#665c54',           // Gruvbox Gray
                edgeArrow: '#504945',          // Gruvbox Dark Gray
                cyBackground: '#282828',       // Gruvbox Background
                textOutlineDark: '#282828',    // Dark outline
                textOutlineLight: '#ebdbb2'    // Light outline
            },
            'tokyo-night': {
                // Tokyo Night - Clean, elegant dark theme
                nodeRoot: '#f7768e',           // Tokyo Night Red
                nodeRootText: '#1a1b26',       // Dark text on red
                nodeClickable: '#ff9e64',      // Tokyo Night Orange
                nodeClickableText: '#1a1b26',  // Dark text on orange
                nodeRegular: '#7aa2f7',        // Tokyo Night Blue
                nodeRegularText: '#1a1b26',    // Dark text on blue
                nodeClass: '#bb9af7',          // Tokyo Night Purple
                nodeClassText: '#1a1b26',      // Dark text on purple
                nodeFunction: '#9ece6a',       // Tokyo Night Green
                nodeFunctionText: '#1a1b26',   // Dark text on green
                nodeMethod: '#f7768e',         // Tokyo Night Red
                nodeMethodText: '#1a1b26',     // Dark text on red
                nodeExternalDirect: '#414868', // Tokyo Night Dark
                nodeExternalDirectText: '#c0caf5', // Light text on dark
                nodeExternalIndirect: '#24283b', // Tokyo Night Darker
                nodeExternalIndirectText: '#c0caf5', // Light text on dark
                nodeHover: '#e0af68',          // Tokyo Night Yellow
                nodeHoverText: '#1a1b26',      // Dark text on yellow
                edgeLine: '#565f89',           // Tokyo Night Comment
                edgeArrow: '#414868',          // Tokyo Night Dark
                cyBackground: '#1a1b26',       // Tokyo Night Background
                textOutlineDark: '#1a1b26',    // Dark outline
                textOutlineLight: '#c0caf5'    // Light outline
            }
        };

        // Theme state
        let currentTheme = localStorage.getItem('codezoom_theme') || 'light';

        // Navigation state
        let currentNode = MULTI_ROOT ? TOP_LEVEL : ROOT_IDS[0];
        const history = [currentNode];

        // Hidden nodes tracking
        const userHiddenNodes = new Set();

        let cy = null;

        // Middle-click highlight state
        const highlightColors = ['#f39c12', '#3498db', '#e74c3c', '#2ecc71']; // amber, blue, red, green
        let highlightSelections = []; // array of { nodeId, colorIndex }

        function blendColors(base, overlay, amount) {
            // Parse a color string (hex or rgb()) into [r, g, b]
            const parseColor = (color) => {
                if (typeof color !== 'string') return [128, 128, 128];
                color = color.trim();
                const rgbMatch = color.match(/^rgb\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)$/);
                if (rgbMatch) {
                    return [parseInt(rgbMatch[1]), parseInt(rgbMatch[2]), parseInt(rgbMatch[3])];
                }
                const hex = color.replace('#', '');
                if (hex.length === 3) {
                    return [parseInt(hex[0]+hex[0],16), parseInt(hex[1]+hex[1],16), parseInt(hex[2]+hex[2],16)];
                }
                return [parseInt(hex.substr(0,2),16), parseInt(hex.substr(2,2),16), parseInt(hex.substr(4,2),16)];
            };
            const b = parseColor(base);
            const o = parseColor(overlay);
            const r = Math.round(b[0] + (o[0] - b[0]) * amount);
            const g = Math.round(b[1] + (o[1] - b[1]) * amount);
            const bl = Math.round(b[2] + (o[2] - b[2]) * amount);
            return '#' + [r, g, bl].map(c => Math.max(0, Math.min(255, c)).toString(16).padStart(2, '0')).join('');
        }

        // Drag with descendants state
        let draggedSubtree = null;
        let initialPositions = null;

        function getBorderStyleForVisibility(visibility) {
            // Map visibility to border style (UML convention)
            // public: solid, protected: dotted, package: double, private: dashed
            if (!visibility) return 'solid';  // Default to solid
            switch (visibility) {
                case 'public': return 'solid';
                case 'protected': return 'dotted';
                case 'package': return 'double';
                case 'private': return 'dashed';
                default: return 'solid';
            }
        }

        // Helper to determine if a color is light or dark
        function isLightColor(color) {
            if (!color) return false;
            const hex = color.replace('#', '');
            if (hex.length === 3) {
                const r = parseInt(hex[0] + hex[0], 16);
                const g = parseInt(hex[1] + hex[1], 16);
                const b = parseInt(hex[2] + hex[2], 16);
                return (r + g + b) / 3 > 127;
            }
            const r = parseInt(hex.substr(0, 2), 16);
            const g = parseInt(hex.substr(2, 2), 16);
            const b = parseInt(hex.substr(4, 2), 16);
            return (r + g + b) / 3 > 127;
        }

        function getDescendants(nodeId) {
            // Recursively collect all descendants by following outgoing edges in the graph
            const descendants = new Set([nodeId]);
            const visited = new Set([nodeId]);
            const toVisit = [nodeId];

            while (toVisit.length > 0) {
                const currentId = toVisit.pop();
                const currentNode = cy.getElementById(currentId);

                if (currentNode.length > 0) {
                    // Get all outgoing edges (edges where this node is the source)
                    const outgoingEdges = currentNode.connectedEdges().filter(edge => {
                        return edge.source().id() === currentId;
                    });

                    // Add target nodes as descendants
                    outgoingEdges.forEach(edge => {
                        const targetId = edge.target().id();
                        if (!visited.has(targetId)) {
                            visited.add(targetId);
                            descendants.add(targetId);
                            toVisit.push(targetId);
                        }
                    });
                }
            }

            return Array.from(descendants);
        }

        function applyColorsToNode(node, colors) {
            const d = node.data();
            const type = d.nodeType || 'regular'; // Default to regular

            // Simple type-to-color mapping
            const colorMap = {
                'root': [colors.nodeRoot, colors.nodeRootText],
                'clickable': [colors.nodeClickable, colors.nodeClickableText],
                'regular': [colors.nodeRegular, colors.nodeRegularText],
                'class': [colors.nodeClass, colors.nodeClassText],
                'function': [colors.nodeFunction, colors.nodeFunctionText],
                'method': [colors.nodeMethod, colors.nodeMethodText],
                'external-direct': [colors.nodeExternalDirect, colors.nodeExternalDirectText],
                'external-indirect': [colors.nodeExternalIndirect, colors.nodeExternalIndirectText],
            };

            const [bgColor, textColor] = colorMap[type] || [colors.nodeRegular, colors.nodeRegularText];

            // Choose outline color based on text color brightness
            const outlineColor = isLightColor(textColor) ? colors.textOutlineDark : colors.textOutlineLight;

            node.style('background-color', bgColor);
            node.style('color', textColor);
            node.style('text-outline-color', outlineColor);

            if (d.borderWidth) node.style('border-width', d.borderWidth);
            if (d.borderColor) node.style('border-color', d.borderColor);

            // Apply border style based on visibility
            const borderStyle = getBorderStyleForVisibility(d.visibility);
            node.style('border-style', borderStyle);

            if (node.isParent()) {
                node.style('background-opacity', 0.15);
                node.style('border-style', 'dashed');
            }

            // Selection overlay using the theme hover color
            if (node.selected()) {
                node.style('overlay-color', colors.nodeHover);
                node.style('overlay-opacity', 0.4);
                node.style('overlay-padding', '6px');
            } else {
                node.style('overlay-opacity', 0);
            }
        }

        function applyNodeColors() {
            if (!cy) return;
            const colors = themes[currentTheme];

            cy.nodes().forEach(node => {
                applyColorsToNode(node, colors);
            });
        }

        function toggleHighlight(nodeId) {
            const existingIdx = highlightSelections.findIndex(s => s.nodeId === nodeId);
            if (existingIdx !== -1) {
                // Remove highlight from this node
                highlightSelections.splice(existingIdx, 1);
            } else {
                // Find the next available color index
                const usedIndices = new Set(highlightSelections.map(s => s.colorIndex));
                let colorIndex = 0;
                while (usedIndices.has(colorIndex) && colorIndex < highlightColors.length) {
                    colorIndex++;
                }
                colorIndex = colorIndex % highlightColors.length;
                highlightSelections.push({ nodeId, colorIndex });
            }
            applyHighlights();
        }

        function clearAllHighlights() {
            highlightSelections = [];
            applyHighlights();
        }

        function isExpandableNode(nodeId) {
            if (nodeId.includes(':') || nodeId.startsWith('ext-dep-')) return false;
            return !!(functionData[nodeId] && Object.keys(functionData[nodeId]).length > 0);
        }

        function isDrillableNode(nodeId) {
            const hasChildren = hierarchy[nodeId] && hierarchy[nodeId].children && hierarchy[nodeId].children.length > 0;
            const hasFunctions = functionData[nodeId] && Object.keys(functionData[nodeId]).length > 0;
            if (hasChildren || hasFunctions) return true;
            if (nodeId.includes(':')) {
                const lastColonIdx = nodeId.lastIndexOf(':');
                const moduleId = nodeId.substring(0, lastColonIdx);
                const symbolPath = nodeId.substring(lastColonIdx + 1);
                const symbolInfo = findSymbol(moduleId, symbolPath);
                return !!(symbolInfo && symbolInfo.type === 'class' && symbolInfo.methods && Object.keys(symbolInfo.methods).length > 0);
            }
            return false;
        }

        function updateDisplayButtons() {
            const hideShowBtn = document.getElementById('hideShowBtn');
            const highlightBtn = document.getElementById('highlightBtn');
            const expandBtn = document.getElementById('expandBtn');
            if (!hideShowBtn || !highlightBtn) return;
            if (!cy || cy.nodes(':selected').length === 0) {
                hideShowBtn.disabled = true;
                hideShowBtn.title = 'Hide selected nodes';
                highlightBtn.disabled = true;
                highlightBtn.title = 'Highlight selected nodes';
                if (expandBtn) { expandBtn.disabled = true; expandBtn.title = 'Expand selected nodes'; }
                return;
            }
            const selected = cy.nodes(':selected');
            hideShowBtn.disabled = false;
            let allHidden = true;
            selected.forEach(n => { if (!n.hasClass('user-hidden')) allHidden = false; });
            hideShowBtn.title = allHidden ? 'Show selected nodes' : 'Hide selected nodes';

            highlightBtn.disabled = false;
            let allHighlighted = true;
            selected.forEach(n => { if (!highlightSelections.some(s => s.nodeId === n.id())) allHighlighted = false; });
            highlightBtn.title = allHighlighted ? 'Unhighlight selected nodes' : 'Highlight selected nodes';

            if (expandBtn) {
                const expandable = selected.filter(n => isExpandableNode(n.id()));
                if (expandable.length === 0) {
                    expandBtn.disabled = true;
                    expandBtn.title = 'Expand selected nodes';
                } else {
                    expandBtn.disabled = false;
                    const allExpanded = expandable.every(n => expandedNodes.has(n.id()));
                    expandBtn.title = allExpanded ? 'Collapse selected nodes' : 'Expand selected nodes';
                }
            }
        }

        function toggleHideShowSelected() {
            if (!cy) return;
            const selected = cy.nodes(':selected');
            if (selected.length === 0) return;
            let allHidden = true;
            selected.forEach(n => { if (!n.hasClass('user-hidden')) allHidden = false; });
            if (allHidden) {
                selected.forEach(node => {
                    userHiddenNodes.delete(node.id());
                    node.removeClass('user-hidden');
                    node.style('display', 'element');
                    node.style('opacity', 1);
                });
            } else {
                selected.forEach(node => {
                    userHiddenNodes.add(node.id());
                    node.addClass('user-hidden');
                });
                updateHiddenDisplay();
            }
            updateDisplayButtons();
        }

        function toggleHighlightSelected() {
            if (!cy) return;
            const selected = cy.nodes(':selected');
            if (selected.length === 0) return;
            const selectedIds = [];
            selected.forEach(n => selectedIds.push(n.id()));
            const allHighlighted = selectedIds.every(id => highlightSelections.some(s => s.nodeId === id));
            if (allHighlighted) {
                const idSet = new Set(selectedIds);
                highlightSelections = highlightSelections.filter(s => !idSet.has(s.nodeId));
            } else {
                selectedIds.forEach(nodeId => {
                    if (highlightSelections.some(s => s.nodeId === nodeId)) return;
                    const usedIndices = new Set(highlightSelections.map(s => s.colorIndex));
                    let colorIndex = 0;
                    while (usedIndices.has(colorIndex) && colorIndex < highlightColors.length) colorIndex++;
                    colorIndex = colorIndex % highlightColors.length;
                    highlightSelections.push({ nodeId, colorIndex });
                });
            }
            applyHighlights();
            updateDisplayButtons();
        }

        function toggleExpandSelected() {
            if (!cy) return;
            const selected = cy.nodes(':selected');
            const expandable = selected.filter(n => isExpandableNode(n.id()));
            if (expandable.length === 0) return;
            const allExpanded = expandable.every(n => expandedNodes.has(n.id()));
            expandable.forEach(n => {
                if (allExpanded) expandedNodes.delete(n.id());
                else expandedNodes.add(n.id());
            });
            updateUI();
        }

        // Context menu
        let contextMenuNode = null;

        function showContextMenu(x, y, node) {
            contextMenuNode = node;
            const nodeId = node.id();
            const expandItem = document.getElementById('ctx-expand');
            if (isExpandableNode(nodeId)) {
                expandItem.style.display = 'block';
                expandItem.textContent = expandedNodes.has(nodeId) ? 'Collapse' : 'Expand';
            } else {
                expandItem.style.display = 'none';
            }
            const drillItem = document.getElementById('ctx-drill-in');
            drillItem.style.display = isDrillableNode(nodeId) ? 'block' : 'none';
            const hideShowItem = document.getElementById('ctx-hide-show');
            hideShowItem.textContent = userHiddenNodes.has(nodeId) ? 'Show' : 'Hide';
            const highlightItem = document.getElementById('ctx-highlight');
            highlightItem.textContent = highlightSelections.some(s => s.nodeId === nodeId) ? 'Unhighlight' : 'Highlight';
            const menu = document.getElementById('context-menu');
            menu.style.left = x + 'px';
            menu.style.top = y + 'px';
            menu.style.display = 'block';
        }

        function hideContextMenu() {
            document.getElementById('context-menu').style.display = 'none';
            contextMenuNode = null;
        }

        function ctxExpand() {
            const nodeId = contextMenuNode ? contextMenuNode.id() : null;
            hideContextMenu();
            if (nodeId) toggleExpand(nodeId);
        }

        function ctxDrillIn() {
            const nodeId = contextMenuNode ? contextMenuNode.id() : null;
            hideContextMenu();
            if (nodeId) drillInto(nodeId);
        }

        function ctxHideShow() {
            if (!contextMenuNode) { hideContextMenu(); return; }
            const node = contextMenuNode;
            const nodeId = node.id();
            if (userHiddenNodes.has(nodeId)) {
                userHiddenNodes.delete(nodeId);
                node.removeClass('user-hidden');
                node.style('display', 'element');
                node.style('opacity', 1);
            } else {
                userHiddenNodes.add(nodeId);
                node.addClass('user-hidden');
                updateHiddenDisplay();
            }
            updateDisplayButtons();
            hideContextMenu();
        }

        function ctxHighlight() {
            if (contextMenuNode) toggleHighlight(contextMenuNode.id());
            hideContextMenu();
        }

        function applyHighlights() {
            if (!cy) return;
            const colors = themes[currentTheme];

            // Reset all nodes to base theme colors
            applyNodeColors();

            // Reset all edges to base style
            cy.edges().forEach(edge => {
                if (edge.data('type') === 'inherits') {
                    edge.style({
                        'line-color': colors.nodeRoot,
                        'target-arrow-color': colors.nodeRoot,
                        'width': 3,
                        'opacity': 0.7
                    });
                } else {
                    edge.style({
                        'line-color': colors.edgeLine,
                        'target-arrow-color': colors.edgeArrow,
                        'width': 2,
                        'opacity': 0.7
                    });
                }
            });

            // Reset all node opacities and underlay (unless user-hidden)
            cy.nodes().forEach(node => {
                if (!userHiddenNodes.has(node.id())) {
                    node.style('opacity', 1);
                }
                node.style('underlay-opacity', 0);
            });

            if (highlightSelections.length === 0) return;

            // Build neighbor hit map: nodeId -> array of colorIndex values
            const neighborHits = {};
            const highlightedEdges = new Set();

            // Prune selections whose nodes no longer exist in the view
            highlightSelections = highlightSelections.filter(s => cy.getElementById(s.nodeId).length > 0);

            for (const sel of highlightSelections) {
                const node = cy.getElementById(sel.nodeId);
                if (node.length === 0) continue;

                const connectedEdges = node.connectedEdges();
                connectedEdges.forEach(edge => {
                    highlightedEdges.add(edge.id());
                    // Style the edge
                    const hColor = highlightColors[sel.colorIndex];
                    edge.style({
                        'line-color': hColor,
                        'target-arrow-color': hColor,
                        'opacity': 1.0,
                        'width': 3
                    });

                    // Find the neighbor node (the other end of the edge)
                    edge.connectedNodes().forEach(n => {
                        if (n.id() !== sel.nodeId) {
                            if (!neighborHits[n.id()]) neighborHits[n.id()] = [];
                            neighborHits[n.id()].push(sel.colorIndex);
                        }
                    });
                });
            }

            // Apply styling to highlighted (clicked) nodes
            const highlightedNodeIds = new Set(highlightSelections.map(s => s.nodeId));

            for (const sel of highlightSelections) {
                const node = cy.getElementById(sel.nodeId);
                if (node.length === 0) continue;
                const hColor = highlightColors[sel.colorIndex];
                const baseBg = node.style('background-color');
                node.style({
                    'background-color': blendColors(baseBg, hColor, 0.65),
                    'border-color': hColor,
                    'border-width': 6,
                    'border-style': 'solid',
                    'underlay-color': hColor,
                    'underlay-opacity': 0.4,
                    'underlay-padding': 8,
                    'opacity': 1
                });
            }

            // Apply styling to neighbor nodes
            for (const [nId, colorIndices] of Object.entries(neighborHits)) {
                if (highlightedNodeIds.has(nId)) continue; // skip nodes that are themselves highlighted
                const node = cy.getElementById(nId);
                if (node.length === 0) continue;

                let baseBg = node.style('background-color');
                const hitCount = colorIndices.length;

                if (hitCount === 1) {
                    const hColor = highlightColors[colorIndices[0]];
                    node.style({
                        'background-color': blendColors(baseBg, hColor, 0.2),
                        'border-color': hColor,
                        'border-width': 2,
                        'opacity': 1
                    });
                } else {
                    // Multiple highlights touch this neighbor ‚Äî blend each sequentially
                    const uniqueColors = [...new Set(colorIndices)];
                    let blended = baseBg;
                    for (const ci of uniqueColors) {
                        blended = blendColors(blended, highlightColors[ci], 0.35);
                    }
                    node.style({
                        'background-color': blended,
                        'border-color': highlightColors[uniqueColors[0]],
                        'border-width': 3,
                        'opacity': 1
                    });
                }
            }

            // Dim unrelated nodes
            cy.nodes().forEach(node => {
                const nId = node.id();
                if (highlightedNodeIds.has(nId)) return;
                if (neighborHits[nId]) return;
                if (userHiddenNodes.has(nId)) return;
                node.style('opacity', 0.4);
            });
        }

        function initCytoscape() {
            if (cy) cy.destroy();

            const colors = themes[currentTheme];

            cy = cytoscape({
                container: document.getElementById('cy'),
                elements: buildGraphData(currentNode),
                style: [
                    {
                        selector: 'node',
                        style: {
                            'content': 'data(label)',
                            'width': 50,
                            'height': 50,
                            'padding': '5px',
                            'text-opacity': 1,
                            'text-wrap': 'wrap',
                            'font-size': '12px',
                            'font-weight': 'bold',
                            'text-valign': 'center',
                            'text-halign': 'center',
                            'background-color': colors.nodeRegular,
                            'border-width': 2,
                            'border-color': '#2980b9',
                            'background-opacity': 0.9,
                            'text-outline-width': 1.5,
                            'text-outline-color': colors.textOutlineDark,
                        }
                    },
                    {
                        selector: 'edge',
                        style: {
                            'curve-style': 'straight',
                            'target-arrow-shape': 'triangle',
                            'target-arrow-color': colors.edgeArrow,
                            'target-arrow-fill': 'filled',
                            'arrow-scale': 1.5,
                            'line-color': colors.edgeLine,
                            'width': 2,
                            'opacity': 0.7,
                        }
                    },
                    {
                        selector: 'edge[type="inherits"]',
                        style: {
                            'target-arrow-shape': 'vee',
                            'target-arrow-color': colors.nodeRoot, // !!!
                            'line-color': colors.nodeRoot, // !!!
                            'line-style': 'dashed',
                            'width': 3,
                            'z-index': 10,
                        }
                    },
                    {
                        selector: 'node.hover',
                        style: {
                            'background-color': colors.nodeHover,
                            'color': colors.nodeHoverText,
                            'border-color': '#d68910',
                        }
                    },
                    {
                        selector: 'node:parent',
                        style: {
                            'text-valign': 'top',
                            'text-halign': 'center',
                            'padding': 20,
                            'background-opacity': 0.15,
                            'border-style': 'dashed',
                        }
                    },
                ],
                layout: {
                    name: 'cose',
                    directed: true,
                    animate: true,
                    animationDuration: 500,
                },
                boxSelectionEnabled: true,
                wheelSensitivity: 0.05,
                minZoom: 0.1,
                maxZoom: 3,
            });

            // Handle hover state
            cy.on('mouseover', 'node', function(evt) {
                const node = evt.target;
                const colors = themes[currentTheme];
                const outlineColor = isLightColor(colors.nodeHoverText) ? colors.textOutlineDark : colors.textOutlineLight;
                node.style({
                    'background-color': colors.nodeHover,
                    'color': colors.nodeHoverText,
                    'border-color': colors.nodeHover,
                    'text-outline-color': outlineColor
                });
            });

            cy.on('mouseout', 'node', function(evt) {
                const node = evt.target;
                const colors = themes[currentTheme];
                applyColorsToNode(node, colors);
                // Reapply highlights so highlighted/neighbor tints aren't lost
                if (highlightSelections.length > 0) applyHighlights();
            });

            // Double-click to drill into a node
            cy.on('dbltap', 'node', function(evt) {
                const nodeId = evt.target.id();
                if (isDrillableNode(nodeId)) drillInto(nodeId);
            });

            // Update selection overlay and Display buttons when selection changes
            cy.on('select unselect', 'node', function(evt) {
                applyColorsToNode(evt.target, themes[currentTheme]);
                updateDisplayButtons();
            });

            // Right-click: show context menu
            cy.on('cxttap', 'node', function(evt) {
                evt.originalEvent.preventDefault();
                const e = evt.originalEvent;
                showContextMenu(e.clientX, e.clientY, evt.target);
            });

            // Alt + drag to move node with all descendants
            cy.on('grab', 'node', function(evt) {
                const node = evt.target;
                const nodeId = node.id();

                // Check if Alt key is pressed
                if (evt.originalEvent && evt.originalEvent.altKey) {
                    // Get all descendants
                    draggedSubtree = getDescendants(nodeId);

                    // Store initial positions
                    initialPositions = new Map();
                    draggedSubtree.forEach(id => {
                        const n = cy.getElementById(id);
                        if (n.length > 0) {
                            initialPositions.set(id, { x: n.position().x, y: n.position().y });
                        }
                    });
                }
            });

            cy.on('drag', 'node', function(evt) {
                if (draggedSubtree && initialPositions) {
                    const node = evt.target;
                    const nodeId = node.id();
                    const initialPos = initialPositions.get(nodeId);

                    if (initialPos) {
                        // Calculate delta from initial position
                        const delta = {
                            x: node.position().x - initialPos.x,
                            y: node.position().y - initialPos.y
                        };

                        // Move all descendants by the same delta
                        draggedSubtree.forEach(id => {
                            if (id !== nodeId) {
                                const n = cy.getElementById(id);
                                const initial = initialPositions.get(id);
                                if (n.length > 0 && initial) {
                                    n.position({ x: initial.x + delta.x, y: initial.y + delta.y });
                                }
                            }
                        });
                    }
                }
            });

            cy.on('free', 'node', function(evt) {
                // Clear drag state when mouse is released
                draggedSubtree = null;
                initialPositions = null;
            });

            setTimeout(() => {
                applyNodeColors();
                applyVisibilityFilter();  // Apply filter after layout
                if (highlightSelections.length > 0) applyHighlights();
                cy.fit();
                syncZoomSlider();  // Set up zoom event listener
                updateDisplayButtons();  // Reset Display buttons for new graph
            }, 100);
        }

        function findSymbol(moduleId, symbolPath) {
            // Navigate through nested classes to find a symbol
            // symbolPath can be:
            //  - "ClassName" (top-level class)
            //  - "OuterClass.InnerClass" (nested class)
            //  - "ClassName.method(args)" (method in class)
            //  - "OuterClass.InnerClass.method(args)" (method in nested class)
            if (!functionData[moduleId]) return null;

            // First, try direct lookup (for top-level classes/functions)
            if (functionData[moduleId][symbolPath]) {
                return functionData[moduleId][symbolPath];
            }

            // For nested symbols, navigate through the structure
            // Split into potential class path and member name
            const parts = symbolPath.split('.');

            // Start with the top-level class
            let current = functionData[moduleId][parts[0]];
            if (!current) return null;

            if (parts.length === 1) return current;

            // Navigate through potential nested classes and methods
            // Try to find the longest matching qualified name first
            for (let i = 1; i < parts.length; i++) {
                if (!current.methods) return null;

                // Try qualified name first (for inner classes like "Outer.Inner")
                const qualifiedName = parts.slice(0, i + 1).join('.');
                if (current.methods[qualifiedName]) {
                    current = current.methods[qualifiedName];
                    continue;
                }

                // Try simple name (for methods like "method()")
                const simpleName = parts.slice(i).join('.');
                if (current.methods[simpleName]) {
                    return current.methods[simpleName];
                }

                return null;
            }

            return current;
        }

        function buildGraphData(nodeId) {
            const elements = [];

            // Method-level nodes (format: "moduleId:symbolPath")
            // symbolPath can be a class, inner class, or method
            if (nodeId.includes(':')) {
                const lastColonIdx = nodeId.lastIndexOf(':');
                const moduleId = nodeId.substring(0, lastColonIdx);
                const symbolPath = nodeId.substring(lastColonIdx + 1);

                // Find the symbol (could be nested)
                const symbol = findSymbol(moduleId, symbolPath);

                // If it's a class with methods/children, show them
                if (symbol && symbol.type === 'class' && symbol.methods) {
                    return buildMethodGraph(moduleId, symbolPath);
                }
            }

            // Top-level: show root nodes and external dependencies
            if (nodeId === TOP_LEVEL || (nodeId === ROOT_IDS[0] && history.length === 1 && !MULTI_ROOT)) {
                const seenEdges = new Set();
                const isTopDeps = (nodeId === ROOT_IDS[0] && !MULTI_ROOT && pythonDeps.length > 0);
                const isMultiTop = (nodeId === TOP_LEVEL && MULTI_ROOT);

                if (isTopDeps || isMultiTop) {
                    // External dependency nodes
                    pythonDeps.forEach(dep => {
                        const isDirect = pythonDepsDirect.includes(dep);
                        elements.push({
                            data: {
                                id: 'ext-dep-' + dep,
                                label: dep.replace(':', '\n'),
                                nodeType: isDirect ? 'external-direct' : 'external-indirect',
                                borderWidth: isDirect ? 2 : 1,
                                borderColor: isDirect ? '#2c3e50' : '#7f8c8d',
                            }
                        });
                    });

                    // Edges between external deps
                    pythonDeps.forEach(dep => {
                        if (pythonDepsGraph[dep]) {
                            pythonDepsGraph[dep].forEach(depDep => {
                                if (pythonDeps.includes(depDep)) {
                                    const edgeId = 'ext-dep-' + dep + '->ext-dep-' + depDep;
                                    if (!seenEdges.has(edgeId)) {
                                        elements.push({ data: { id: edgeId, source: 'ext-dep-' + dep, target: 'ext-dep-' + depDep, type: 'dependency' } });
                                        seenEdges.add(edgeId);
                                    }
                                }
                            });
                        }
                    });

                    if (isMultiTop) {
                        // Multi-root: each root is a top-level node
                        ROOT_IDS.forEach(rootId => {
                            const rootNode = hierarchy[rootId];
                            const hasChildren = rootNode && rootNode.children && rootNode.children.length > 0;
                            const rootHasFunctions = functionData[rootId];
                            const isClickable = hasChildren || rootHasFunctions;
                            elements.push({
                                data: {
                                    id: rootId,
                                    label: rootId,
                                    nodeType: 'root',
                                    borderWidth: 3,
                                    borderColor: '#c0392b',
                                    isClickable: isClickable,
                                }
                            });

                            // Inter-module edges
                            if (rootNode) {
                                (rootNode.imports_to || []).forEach(targetId => {
                                    if (ROOT_IDS.includes(targetId)) {
                                        const edgeId = rootId + '->' + targetId;
                                        if (!seenEdges.has(edgeId)) {
                                            elements.push({ data: { id: edgeId, source: rootId, target: targetId } });
                                            seenEdges.add(edgeId);
                                        }
                                    }
                                });
                            }

                            // Module ‚Üí external dependency edges
                            if (moduleDirectDeps[rootId]) {
                                moduleDirectDeps[rootId].forEach(dep => {
                                    const edgeId = rootId + '->ext-dep-' + dep;
                                    if (!seenEdges.has(edgeId)) {
                                        elements.push({ data: { id: edgeId, source: rootId, target: 'ext-dep-' + dep, type: 'dependency' } });
                                        seenEdges.add(edgeId);
                                    }
                                });
                            }
                        });
                    } else {
                        // Single-root: one root node with edges to direct deps
                        const rootId = ROOT_IDS[0];
                        elements.push({
                            data: {
                                id: rootId,
                                label: data.project_name,
                                nodeType: 'root',
                                borderWidth: 3,
                                borderColor: '#c0392b',
                            }
                        });

                        pythonDepsDirect.forEach(dep => {
                            const edgeId = rootId + '->ext-dep-' + dep;
                            if (!seenEdges.has(edgeId)) {
                                elements.push({ data: { id: edgeId, source: rootId, target: 'ext-dep-' + dep, type: 'dependency' } });
                                seenEdges.add(edgeId);
                            }
                        });
                    }

                    return elements;
                }
            }

            // Regular hierarchy node
            const node = hierarchy[nodeId];
            if (!node) return elements;

            const children = node.children || [];
            const hasFunctions = functionData[nodeId] && Object.keys(functionData[nodeId]).length > 0;

            // Leaf module with function data only (no sub-package children)
            if (hasFunctions && children.length === 0) {
                return buildFunctionGraph(nodeId);
            }

            // Build child package nodes
            const childSet = new Set(children);

            if (children.length > 0) {
                children.forEach(childId => {
                    const childNode = hierarchy[childId];
                    const hasChildren = childNode && childNode.children && childNode.children.length > 0;
                    const childHasFunctions = functionData[childId];
                    const isClickable = hasChildren || childHasFunctions;

                    const isPrivate = childNode && childNode.is_exported === false;
                    elements.push({
                        data: {
                            id: childId,
                            label: childId.split('.').pop(),
                            nodeType: isClickable ? 'clickable' : 'regular',
                            borderWidth: isClickable ? 3 : 2,
                            borderColor: isClickable ? '#d68910' : '#2980b9',
                            visibility: isPrivate ? 'private' : null,
                        }
                    });

                    if (expandedNodes.has(childId) && functionData[childId]) {
                        // Add class/function children as compound children
                        const fns = functionData[childId];
                        Object.entries(fns).forEach(([name, info]) => {
                            const childNodeId = childId + ':' + name;
                            const hasMethodsOrCalls = (info.methods && Object.keys(info.methods).length > 0)
                                                   || (info.calls && info.calls.length > 0);
                            const originShort = info.origin ? info.origin.split('.').pop() : null;
                            elements.push({
                                data: {
                                    id: childNodeId,
                                    label: originShort ? name + '\n‚Üó ' + originShort : name,
                                    parent: childId,
                                    nodeType: info.type === 'class' ? 'class' : 'function',
                                    borderWidth: hasMethodsOrCalls ? 3 : 2,
                                    borderColor: info.type === 'class' ? '#8e44ad' : '#117a65',
                                    hasChildren: info.type === 'class' && info.methods && Object.keys(info.methods).length > 0,
                                    visibility: info.visibility || null,
                                    origin: info.origin || null,
                                }
                            });
                        });

                        // Internal call/inherits edges within expanded package
                        Object.entries(fns).forEach(([name, info]) => {
                            if (info.calls) {
                                info.calls.forEach(calledName => {
                                    if (fns[calledName]) {
                                        const edgeId = childId + ':' + name + '->' + calledName;
                                        if (!elements.find(el => el.data.id === edgeId))
                                            elements.push({ data: { id: edgeId, source: childId + ':' + name, target: childId + ':' + calledName, type: 'call' } });
                                    }
                                });
                            }
                            if (info.inherits) {
                                info.inherits.forEach(baseName => {
                                    if (fns[baseName]) {
                                        const edgeId = childId + ':' + name + '->inherits-' + baseName;
                                        if (!elements.find(el => el.data.id === edgeId))
                                            elements.push({ data: { id: edgeId, source: childId + ':' + name, target: childId + ':' + baseName, type: 'inherits' } });
                                    }
                                });
                            }
                        });

                        // Same-package class_deps edges (targets without '.' are same-package classes)
                        const classDeps = hierarchy[childId] && hierarchy[childId].class_deps;
                        if (classDeps) {
                            const childNodeIds = new Set(Object.keys(fns).map(n => childId + ':' + n));
                            Object.entries(classDeps).forEach(([srcClass, targets]) => {
                                const srcId = childId + ':' + srcClass;
                                if (!childNodeIds.has(srcId)) return;
                                targets.forEach(target => {
                                    if (target.includes('.')) return; // cross-package: can't resolve to class node
                                    const tgtId = childId + ':' + target;
                                    if (!childNodeIds.has(tgtId) || srcId === tgtId) return;
                                    const edgeId = srcId + '->cdep-' + target;
                                    if (!elements.find(el => el.data.id === edgeId))
                                        elements.push({ data: { id: edgeId, source: srcId, target: tgtId, type: 'dependency' } });
                                });
                            });
                        }
                    }
                });

                children.forEach(childId => {
                    const childNode = hierarchy[childId];
                    if (childNode && childNode.imports_to) {
                        childNode.imports_to.forEach(targetId => {
                            if (childSet.has(targetId) && childId !== targetId) {
                                const edgeId = childId + '->' + targetId;
                                if (!elements.find(el => el.data.id === edgeId)) {
                                    elements.push({ data: { id: edgeId, source: childId, target: targetId, type: 'import' } });
                                }
                            }
                        });
                    }
                });
            }

            // Also show symbols (classes) alongside sub-package children
            if (hasFunctions) {
                const functions = functionData[nodeId];
                Object.entries(functions).forEach(([name, info]) => {
                    const nodeFullId = nodeId + ':' + name;
                    const hasMethodsOrCalls = (info.methods && Object.keys(info.methods).length > 0) || (info.calls && info.calls.length > 0);
                    const originShort = info.origin ? info.origin.split('.').pop() : null;

                    elements.push({
                        data: {
                            id: nodeFullId,
                            label: originShort ? name + '\n‚Üó ' + originShort : name,
                            nodeType: info.type === 'class' ? 'class' : 'function',
                            borderWidth: hasMethodsOrCalls ? 3 : 2,
                            borderColor: info.type === 'class' ? '#8e44ad' : '#117a65',
                            hasChildren: info.type === 'class' && info.methods && Object.keys(info.methods).length > 0,
                            visibility: info.visibility || null,
                            origin: info.origin || null,
                        }
                    });
                });

                // Add class-level dependency edges from jdeps
                const classDeps = hierarchy[nodeId] && hierarchy[nodeId].class_deps;
                if (classDeps) {
                    const nodeIds = new Set(elements.filter(e => !e.data.source).map(e => e.data.id));

                    Object.entries(classDeps).forEach(([srcClass, targets]) => {
                        const srcId = nodeId + ':' + srcClass;
                        if (!nodeIds.has(srcId)) return;
                        targets.forEach(target => {
                            // target with '.' is a package node ID; without is a same-package class
                            const tgtId = target.includes('.') ? target : nodeId + ':' + target;
                            if (!nodeIds.has(tgtId) || srcId === tgtId) return;
                            const edgeId = srcId + '->dep-' + target;
                            if (!elements.find(el => el.data.id === edgeId)) {
                                elements.push({ data: { id: edgeId, source: srcId, target: tgtId, type: 'dependency' } });
                            }
                        });
                    });
                }
            }

            return elements;
        }

        function buildFunctionGraph(moduleId) {
            const elements = [];
            const functions = functionData[moduleId];
            if (!functions) return elements;

            Object.entries(functions).forEach(([name, info]) => {
                const hasMethodsOrCalls = (info.methods && Object.keys(info.methods).length > 0) || (info.calls && info.calls.length > 0);
                let borderWidth = hasMethodsOrCalls ? 3 : 2;
                const originShort = info.origin ? info.origin.split('.').pop() : null;

                elements.push({
                    data: {
                        id: moduleId + ':' + name,
                        label: originShort ? name + '\n‚Üó ' + originShort : name,
                        nodeType: info.type === 'class' ? 'class' : 'function',
                        borderWidth: borderWidth,
                        borderColor: info.type === 'class' ? '#8e44ad' : '#117a65',
                        hasChildren: info.type === 'class' && info.methods && Object.keys(info.methods).length > 0,
                        visibility: info.visibility || null,
                        origin: info.origin || null,
                    }
                });
            });

            Object.entries(functions).forEach(([name, info]) => {
                if (info.calls && info.calls.length > 0) {
                    info.calls.forEach(calledName => {
                        // Bytecode analysis gives us exact signatures
                        if (functions[calledName]) {
                            const edgeId = moduleId + ':' + name + '->' + calledName;
                            if (!elements.find(el => el.data.id === edgeId)) {
                                elements.push({ data: { id: edgeId, source: moduleId + ':' + name, target: moduleId + ':' + calledName, type: 'call' } });
                            }
                        }
                    });
                }

                if (info.inherits && info.inherits.length > 0) {
                    info.inherits.forEach(parentName => {
                        if (functions[parentName]) {
                            const edgeId = moduleId + ':' + name + '-inherits-' + parentName;
                            if (!elements.find(el => el.data.id === edgeId)) {
                                elements.push({ data: { id: edgeId, source: moduleId + ':' + name, target: moduleId + ':' + parentName, type: 'inherits' } });
                            }
                        }
                    });
                }
            });

            // Add class-level dependency edges from jdeps
            const classDeps = hierarchy[moduleId] && hierarchy[moduleId].class_deps;
            if (classDeps) {
                const nodeIds = new Set(elements.filter(e => !e.data.source).map(e => e.data.id));

                Object.entries(classDeps).forEach(([srcClass, targets]) => {
                    const srcId = moduleId + ':' + srcClass;
                    if (!nodeIds.has(srcId)) return;
                    targets.forEach(target => {
                        // target with '.' is a package node ID; without is a same-package class
                        const tgtId = target.includes('.') ? target : moduleId + ':' + target;
                        if (!nodeIds.has(tgtId) || srcId === tgtId) return;
                        const edgeId = srcId + '->dep-' + target;
                        if (!elements.find(el => el.data.id === edgeId)) {
                            elements.push({ data: { id: edgeId, source: srcId, target: tgtId, type: 'dependency' } });
                        }
                    });
                });
            }

            return elements;
        }

        function buildMethodGraph(moduleId, symbolPath) {
            // symbolPath can be "ClassName" or "OuterClass.InnerClass"
            const elements = [];

            const classInfo = findSymbol(moduleId, symbolPath);
            if (!classInfo) return elements;

            const methods = classInfo.methods || {};

            Object.entries(methods).forEach(([childName, childInfo]) => {
                // Child can be a method or nested class
                const fullChildName = childName.includes('.') ? childName : `${symbolPath}.${childName}`;

                // For display: show just the simple name (last part after final dot)
                let displayLabel = childName;
                if (childInfo.type === 'class' && childName.includes('.')) {
                    // Inner class: show just "InnerClass" not "OuterClass.InnerClass"
                    const parts = childName.split('.');
                    displayLabel = parts[parts.length - 1];
                }

                elements.push({
                    data: {
                        id: moduleId + ':' + fullChildName,
                        label: displayLabel,
                        nodeType: childInfo.type === 'class' ? 'class' : 'method',
                        borderWidth: 2,
                        borderColor: childInfo.type === 'class' ? '#8e44ad' : '#c0392b',
                        visibility: childInfo.visibility || null,
                        hasChildren: childInfo.type === 'class' && childInfo.methods && Object.keys(childInfo.methods).length > 0,
                    }
                });
            });

            Object.entries(methods).forEach(([childName, childInfo]) => {
                if (childInfo.calls && childInfo.calls.length > 0) {
                    const fullChildName = childName.includes('.') ? childName : `${symbolPath}.${childName}`;
                    childInfo.calls.forEach(calledName => {
                        // Bytecode analysis gives us exact signatures, so just check if it exists
                        if (methods[calledName]) {
                            const fullCalledName = calledName.includes('.') ? calledName : `${symbolPath}.${calledName}`;
                            const edgeId = moduleId + ':' + fullChildName + '->' + calledName;
                            if (!elements.find(el => el.data.id === edgeId)) {
                                elements.push({ data: { id: edgeId, source: moduleId + ':' + fullChildName, target: moduleId + ':' + fullCalledName, type: 'call' } });
                            }
                        }
                    });
                }
            });

            return elements;
        }

        function toggleExpand(nodeId) {
            if (expandedNodes.has(nodeId)) expandedNodes.delete(nodeId);
            else expandedNodes.add(nodeId);
            updateUI();
        }

        function drillInto(nodeId) {
            if (!nodeId.includes(':') && !hierarchy[nodeId]) return;
            expandedNodes.clear();
            currentNode = nodeId;
            history.push(nodeId);
            updateUI();
        }

        function goUp() {
            if (history.length > 1) {
                expandedNodes.clear();
                history.pop();
                currentNode = history[history.length - 1];
                updateUI();
            }
        }

        function reset() {
            expandedNodes.clear();
            currentNode = MULTI_ROOT ? TOP_LEVEL : ROOT_IDS[0];
            history.length = 1;
            history[0] = currentNode;
            updateUI();
        }

        function updateHiddenDisplay() {
            if (!cy) return;
            const showHidden = document.getElementById('showHidden').checked;

            cy.nodes('.user-hidden').forEach(node => {
                if (showHidden) {
                    // Translucent mode - show hidden nodes with visual indication
                    node.style('display', 'element');
                    node.style('opacity', 0.3);
                } else {
                    // Completely hidden
                    node.style('display', 'none');
                }
            });
        }

        function toggleHiddenDisplay(showHidden) {
            updateHiddenDisplay();
            // Reapply visibility filter after toggling hidden display
            applyVisibilityFilter();
        }

        function unhideAll() {
            userHiddenNodes.clear();
            if (cy) {
                cy.nodes('.user-hidden').forEach(node => {
                    node.removeClass('user-hidden');
                    node.style('display', 'element');
                    node.style('opacity', 1);
                });
            }
        }

        function getZoomContext() {
            // Determine what level we're viewing
            if (currentNode === TOP_LEVEL || (currentNode === ROOT_IDS[0] && history.length === 1 && !MULTI_ROOT && pythonDeps.length > 0)) {
                return 'dependencies';
            } else if (currentNode.includes(':')) {
                // At class or method level
                const lastColonIdx = currentNode.lastIndexOf(':');
                const classPath = currentNode.substring(lastColonIdx + 1);
                if (classPath.includes('.')) {
                    return 'methods';  // Viewing methods of a class
                } else {
                    return 'members';  // Viewing members (could be methods or classes)
                }
            } else {
                return 'packages';  // Viewing packages/modules
            }
        }

        function detectLanguageFeatures() {
            // Detect which visibility levels are actually used in the project
            const usedVisibilities = new Set();

            // Check all symbols in functionData
            for (const moduleId in functionData) {
                const symbols = functionData[moduleId];
                for (const symbolName in symbols) {
                    const symbol = symbols[symbolName];
                    if (symbol.visibility) {
                        usedVisibilities.add(symbol.visibility);
                    }
                    // Check methods too
                    if (symbol.methods) {
                        for (const methodName in symbol.methods) {
                            const method = symbol.methods[methodName];
                            if (method.visibility) {
                                usedVisibilities.add(method.visibility);
                            }
                        }
                    }
                }
            }

            return {
                hasProtected: usedVisibilities.has('protected'),
                hasPackage: usedVisibilities.has('package'),
            };
        }

        function updateVisibilityCheckboxes() {
            const context = getZoomContext();
            const languageFeatures = detectLanguageFeatures();

            // Hide all checkboxes first
            document.getElementById('vis-direct-label').style.display = 'none';
            document.getElementById('vis-transitive-label').style.display = 'none';
            document.getElementById('vis-public-label').style.display = 'none';
            document.getElementById('vis-protected-label').style.display = 'none';
            document.getElementById('vis-package-label').style.display = 'none';
            document.getElementById('vis-private-label').style.display = 'none';

            // Show relevant checkboxes based on context
            if (context === 'dependencies') {
                document.getElementById('vis-direct-label').style.display = 'block';
                document.getElementById('vis-transitive-label').style.display = 'block';
            } else {
                // Package/class/method views - show code visibility
                document.getElementById('vis-public-label').style.display = 'block';

                // Only show protected/package if they're actually used in the project
                if (languageFeatures.hasProtected) {
                    document.getElementById('vis-protected-label').style.display = 'block';
                }
                if (languageFeatures.hasPackage) {
                    document.getElementById('vis-package-label').style.display = 'block';
                }

                document.getElementById('vis-private-label').style.display = 'block';
            }
        }

        function shouldShowNode(node, context) {
            const nodeId = node.id();
            const nodeData = node.data();

            // Dependencies context
            if (context === 'dependencies') {
                if (nodeId.startsWith('ext-dep-')) {
                    const depName = nodeId.substring(8);  // Remove 'ext-dep-' prefix
                    const isDirect = pythonDepsDirect.includes(depName);

                    // Check visibility checkboxes
                    const showDirect = document.getElementById('vis-direct').checked;
                    const showTransitive = document.getElementById('vis-transitive').checked;

                    if (isDirect && !showDirect) return false;
                    if (!isDirect && !showTransitive) return false;
                }
                return true;  // Show project root
            }

            // Get visibility checkbox states
            const showPublic = document.getElementById('vis-public').checked;
            const showProtected = document.getElementById('vis-protected').checked;
            const showPackage = document.getElementById('vis-package').checked;
            const showPrivate = document.getElementById('vis-private').checked;

            // Check symbol visibility for classes/methods
            if (nodeId.includes(':')) {
                const lastColonIdx = nodeId.lastIndexOf(':');
                const moduleId = nodeId.substring(0, lastColonIdx);
                const symbolPath = nodeId.substring(lastColonIdx + 1);

                // Extract visibility from function data (handles nested classes)
                const symbolInfo = findSymbol(moduleId, symbolPath);
                const visibility = symbolInfo ? symbolInfo.visibility : null;

                if (visibility) {
                    // Filter based on visibility checkboxes
                    if (visibility === 'public' && !showPublic) return false;
                    if (visibility === 'protected' && !showProtected) return false;
                    if (visibility === 'package' && !showPackage) return false;
                    if (visibility === 'private' && !showPrivate) return false;
                }
            }

            // Module/package visibility - check if exported
            // (is_exported is set by language-specific extractors)
            if (!nodeId.includes(':') && hierarchy[nodeId]) {
                const isExported = hierarchy[nodeId].is_exported !== false;
                if (isExported && !showPublic) {
                    return false;  // Hide public/exported packages if public is unchecked
                }
                if (!isExported && !showPrivate) {
                    return false;  // Hide internal/private packages if private is unchecked
                }
            }

            return true;
        }

        function applyVisibilityFilter() {
            if (!cy) return;

            const context = getZoomContext();

            // Update which checkboxes are shown
            updateVisibilityCheckboxes();

            // Apply node filter
            cy.nodes().forEach(node => {
                // Skip user-hidden nodes (they're handled separately)
                if (node.hasClass('user-hidden')) return;

                if (shouldShowNode(node, context)) {
                    node.style('display', 'element');
                } else {
                    node.style('display', 'none');
                }
            });

            // Apply edge filter
            const showInherits = document.getElementById('vis-inherits').checked;
            const showUses = document.getElementById('vis-uses').checked;

            cy.edges().forEach(edge => {
                const edgeType = edge.data('type');
                let shouldShow = true;

                if (edgeType === 'inherits' && !showInherits) shouldShow = false;
                if (edgeType === 'dependency' && !showUses) shouldShow = false;
                if (edgeType === 'call' && !showUses) shouldShow = false;
                if (edgeType === 'import' && !showUses) shouldShow = false;

                if (shouldShow) {
                    edge.style('display', 'element');
                } else {
                    edge.style('display', 'none');
                }
            });
        }

        function updateUI() {
            updateBreadcrumb();
            updateBackButton();
            initCytoscape();
            // applyVisibilityFilter is now called inside initCytoscape's setTimeout
        }

        function updateBreadcrumb() {
            const breadcrumb = document.getElementById('breadcrumb');
            const parts = [];

            history.forEach((nodeId, idx) => {
                if (idx === 0) {
                    // Root: show project name
                    const label = data.project_name;
                    if (history.length === 1) {
                        parts.push('<strong>' + label + '</strong>');
                    } else {
                        parts.push('<a onclick="jumpTo(0)">' + label + '</a>');
                    }
                    return;
                }

                const prevNodeId = history[idx - 1];
                let label = '';
                let separator = '';

                // Determine incremental label and separator based on node type
                if (nodeId.includes(':')) {
                    // Symbol node (class/method): format is "package:Symbol"
                    const colonIdx = nodeId.lastIndexOf(':');
                    const symbolPart = nodeId.substring(colonIdx + 1);

                    if (prevNodeId.includes(':')) {
                        // Previous was also a symbol - check for nesting
                        const prevColonIdx = prevNodeId.lastIndexOf(':');
                        const prevSymbolPath = prevNodeId.substring(prevColonIdx + 1);

                        if (symbolPart.startsWith(prevSymbolPath + '.')) {
                            // Nested symbol (e.g., "Class" -> "Class.method")
                            label = symbolPart.substring(prevSymbolPath.length + 1);
                            separator = '.';
                        } else {
                            // Different symbol at same level
                            label = symbolPart;
                            separator = ':';
                        }
                    } else {
                        // Previous was a package, now showing a symbol
                        label = symbolPart;
                        separator = ':';
                    }
                } else {
                    // Package node
                    if (nodeId.startsWith(prevNodeId + '.')) {
                        // Incremental package (e.g., "org.foo" -> "org.foo.bar")
                        label = nodeId.substring(prevNodeId.length + 1);
                        separator = '.';
                    } else {
                        // First level or different branch
                        label = nodeId;
                        separator = ' &rsaquo; ';
                    }
                }

                // Build HTML
                const isLast = idx === history.length - 1;
                const html = isLast
                    ? '<strong>' + label + '</strong>'
                    : '<a onclick="jumpTo(' + idx + ')">' + label + '</a>';

                parts.push(separator + html);
            });

            breadcrumb.innerHTML = parts.join('');
        }

        function jumpTo(idx) {
            history.length = idx + 1;
            currentNode = history[history.length - 1];
            updateUI();
        }

        function updateBackButton() {
            document.getElementById('backBtn').disabled = history.length <= 1;
        }

        function applyLayout(name, options = {}) {
            if (!cy) return;

            // Sensible defaults for each layout
            const defaults = {
                cose: {
                    nodeRepulsion: 400000,
                    idealEdgeLength: 100,
                    edgeElasticity: 100,
                    animate: 'during',     // Show physics simulation animation
                    refresh: 20,           // Refresh every 20ms for smoother animation
                    numIter: 1000,         // More iterations for better result
                    randomize: false       // Don't randomize positions
                },
                fcose: {
                    quality: 'proof',     // 'default' or 'proof' (slower but better)
                    nodeSeparation: 100,  // Min distance between nodes
                    idealEdgeLength: 75,  // Preferred edge length
                    edgeElasticity: 0.45  // Edge spring strength
                },
                dagre: {
                    rankDir: 'TB',        // Top to bottom
                    nodeSep: 50,          // Horizontal spacing
                    edgeSep: 10,          // Edge spacing
                    rankSep: 50           // Vertical spacing between ranks
                },
                breadthfirst: {
                    directed: true,       // Use edge direction
                    spacingFactor: 1.5    // Spacing multiplier
                },
                concentric: {
                    // Defaults are overridden by concentric_options()
                    // Just set common options here
                    sweep: undefined,          // Auto-calculate sweep angle
                    avoidOverlap: true,        // Prevent node overlaps
                    clockwise: true            // Direction
                },
                circle: {
                    // Note: Cytoscape's circle layout has a sort function parameter,
                    // but it does not seem to ever affect the final graph layout.
                    // Nodes are always arranged alphabetically.
                },
                tidytree: {},
                grid: {
                    rows: undefined,  // Auto-calculate
                    cols: undefined,  // Auto-calculate
                    condense: false,
                    avoidOverlap: true
                },
                random: {}
            };

            // Merge defaults with user options
            const layoutOptions = {
                name: name,
                animate: true,
                animationDuration: 500,
                ...(defaults[name] || {}),
                ...options
            };
            try {
                cy.layout(layoutOptions).run();
            } catch(e) {
                console.log(e);
                if (name !== "cose") applyLayout("cose");
            }
        }

        function applyTheme(theme) {
            // Validate theme exists
            if (!themes[theme]) {
                console.warn(`Theme "${theme}" not found, falling back to light`);
                theme = 'light';
            }

            currentTheme = theme;

            // Update body class for CSS variables
            document.body.className = ''; // Clear all theme classes
            if (theme !== 'light') {
                document.body.classList.add(theme + '-theme');
            }

            // Update Cytoscape colors if graph exists
            if (cy) {
                const colors = themes[theme];

                // Update container background
                document.getElementById('cy').style.background = colors.cyBackground;

                // Update node hover styles
                cy.style()
                    .selector('node.hover').style({
                        'background-color': colors.nodeHover,
                        'color': colors.nodeHoverText
                    })
                    .update();

                // Reapply node-specific colors (this handles text colors too)
                applyNodeColors();
            }

            // Update dropdown selection
            const selector = document.getElementById('themeSelector');
            if (selector) {
                selector.value = theme;
            }

            // Persist to localStorage
            localStorage.setItem('codezoom_theme', theme);
        }

        function changeTheme(theme) {
            applyTheme(theme);
        }

        // Node size slider
        const sizeSlider = document.getElementById('sizeSlider');
        const sizeValue = document.getElementById('sizeValue');

        sizeSlider.addEventListener('input', function() {
            const newSize = this.value;
            sizeValue.textContent = newSize;
            if (cy) {
                cy.nodes().style('width', newSize);
                cy.nodes().style('height', newSize);
            }
        });

        // Font size slider
        const fontSlider = document.getElementById('fontSlider');
        const fontValue = document.getElementById('fontValue');

        fontSlider.addEventListener('input', function() {
            const newFontSize = this.value;
            fontValue.textContent = newFontSize;
            if (cy) {
                cy.nodes().style('font-size', newFontSize + 'px');
            }
        });

        // Zoom slider
        const zoomSlider = document.getElementById('zoomSlider');
        const zoomValue = document.getElementById('zoomValue');

        zoomSlider.addEventListener('input', function() {
            const zoomPercent = this.value;
            zoomValue.textContent = zoomPercent + '%';
            if (cy) {
                // Convert percentage to zoom level (100% = 1.0, 200% = 2.0, etc.)
                // Zoom around the center of the viewport
                cy.zoom({
                    level: zoomPercent / 100,
                    renderedPosition: { x: cy.width() / 2, y: cy.height() / 2 }
                });
            }
        });

        // Sync slider with zoom changes (e.g., from mouse wheel)
        function syncZoomSlider() {
            if (cy) {
                cy.on('zoom', function() {
                    const currentZoom = cy.zoom();
                    const zoomPercent = Math.round(currentZoom * 100);
                    zoomSlider.value = zoomPercent;
                    zoomValue.textContent = zoomPercent + '%';
                });
            }
        }

        // Visibility checkboxes
        const visibilityCheckboxes = [
            'vis-direct', 'vis-transitive',
            'vis-public', 'vis-protected', 'vis-package', 'vis-private',
            'vis-inherits', 'vis-uses'
        ];
        visibilityCheckboxes.forEach(id => {
            const checkbox = document.getElementById(id);
            checkbox.addEventListener('change', function() {
                applyVisibilityFilter();
            });
        });

        // Apply saved theme on page load (before Cytoscape initialization)
        applyTheme(currentTheme);

        // Sidebar resize functionality
        (function() {
            const sidebar = document.getElementById('sidebar');
            const resizeHandle = document.getElementById('resize-handle');
            let isResizing = false;
            let startX = 0;
            let startWidth = 0;

            // Load saved width from localStorage
            const savedWidth = localStorage.getItem('codezoom_sidebar_width');
            if (savedWidth) {
                sidebar.style.width = savedWidth + 'px';
            }

            resizeHandle.addEventListener('mousedown', function(e) {
                isResizing = true;
                startX = e.clientX;
                startWidth = sidebar.offsetWidth;
                resizeHandle.classList.add('dragging');
                document.body.style.cursor = 'col-resize';
                document.body.style.userSelect = 'none';
                e.preventDefault();
            });

            document.addEventListener('mousemove', function(e) {
                if (!isResizing) return;

                const delta = e.clientX - startX;
                const newWidth = startWidth + delta;

                // Respect min/max constraints
                const minWidth = 180;
                const maxWidth = 600;
                const constrainedWidth = Math.max(minWidth, Math.min(maxWidth, newWidth));

                sidebar.style.width = constrainedWidth + 'px';
            });

            document.addEventListener('mouseup', function() {
                if (isResizing) {
                    isResizing = false;
                    resizeHandle.classList.remove('dragging');
                    document.body.style.cursor = '';
                    document.body.style.userSelect = '';

                    // Save width to localStorage
                    localStorage.setItem('codezoom_sidebar_width', sidebar.offsetWidth);
                }
            });
        })();

        function showHelp() {
            document.getElementById('help-overlay').classList.add('visible');
        }
        function hideHelp() {
            document.getElementById('help-overlay').classList.remove('visible');
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            // Don't capture keypresses in form elements
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.tagName === 'TEXTAREA') return;
            if (e.key === 'F1' || (e.key === '?' && !e.ctrlKey && !e.metaKey)) {
                e.preventDefault();
                const overlay = document.getElementById('help-overlay');
                if (overlay.classList.contains('visible')) hideHelp(); else showHelp();
            } else if (e.key === 'Escape') {
                if (document.getElementById('help-overlay').classList.contains('visible')) {
                    hideHelp();
                } else {
                    if (cy) cy.elements().unselect();
                    hideContextMenu();
                }
            } else if (e.ctrlKey && e.key === 'a') {
                e.preventDefault();
                if (cy) cy.nodes(':visible').select();
            } else if (e.key === 'Enter') {
                if (cy) {
                    const selected = cy.nodes(':selected');
                    if (selected.length === 1 && isDrillableNode(selected[0].id())) {
                        drillInto(selected[0].id());
                    }
                }
            } else if (e.key === 'Delete') {
                toggleHideShowSelected();
            } else if (e.key === 'f' && !e.ctrlKey && !e.metaKey) {
                if (cy) cy.fit();
            } else if (e.key === 'h' && !e.ctrlKey && !e.metaKey) {
                toggleHighlightSelected();
            } else if (e.key === 'e' && !e.ctrlKey && !e.metaKey) {
                toggleExpandSelected();
            } else if (e.key === 'Home') {
                e.preventDefault();
                reset();
            }
        });

        // Dismiss context menu on any click outside it
        document.addEventListener('click', function(e) {
            const menu = document.getElementById('context-menu');
            if (menu && !menu.contains(e.target)) hideContextMenu();
        });

        // Initialize
        updateUI();
    </script>
</body>
</html>
