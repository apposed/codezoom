<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>codezoom</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cytoscape/3.28.1/cytoscape.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dagre/0.8.5/dagre.min.js"></script>
    <script src="https://unpkg.com/cytoscape-dagre@2.2.2/cytoscape-dagre.js"></script>
    <style>
        :root {
            /* Light theme (default) */
            --bg-primary: #f5f5f5;
            --bg-secondary: white;
            --text-primary: #222222;
            --text-secondary: #666;
            --text-tertiary: #333;
            --border-color: #ddd;
            --border-color-secondary: #ccc;
            --button-bg: #2c3e50;
            --button-bg-hover: #34495e;
            --button-bg-disabled: #bdc3c7;
            --info-bg: #e8f4f8;
            --info-border: #3498db;
            --breadcrumb-link: #2c3e50;
            --breadcrumb-link-hover: #34495e;
            --shadow-color: rgba(0,0,0,0.1);
        }

        body.dark-theme {
            /* Dark theme overrides */
            --bg-primary: #1e1e1e;
            --bg-secondary: #2d2d2d;
            --text-primary: #e0e0e0;
            --text-secondary: #aaa;
            --text-tertiary: #ccc;
            --border-color: #444;
            --border-color-secondary: #555;
            --button-bg: #4a5568;
            --button-bg-hover: #5a6778;
            --button-bg-disabled: #2d3748;
            --info-bg: #2a3f5f;
            --info-border: #4a9eff;
            --breadcrumb-link: #4a9eff;
            --breadcrumb-link-hover: #6bb0ff;
            --shadow-color: rgba(0,0,0,0.3);
        }

        body.high-contrast-theme {
            /* High contrast theme for accessibility */
            --bg-primary: #ffffff;
            --bg-secondary: #ffffff;
            --text-primary: #000000;
            --text-secondary: #000000;
            --text-tertiary: #000000;
            --border-color: #000000;
            --border-color-secondary: #333333;
            --button-bg: #000000;
            --button-bg-hover: #333333;
            --button-bg-disabled: #999999;
            --info-bg: #ffff99;
            --info-border: #000000;
            --breadcrumb-link: #0000cc;
            --breadcrumb-link-hover: #0000ff;
            --shadow-color: rgba(0,0,0,0.3);
        }

        body.dracula-theme {
            /* Official Dracula theme colors */
            --bg-primary: #282a36;
            --bg-secondary: #282a36;
            --text-primary: #f8f8f2;
            --text-secondary: #6272a4;
            --text-tertiary: #f8f8f2;
            --border-color: #44475a;
            --border-color-secondary: #6272a4;
            --button-bg: #6272a4;
            --button-bg-hover: #bd93f9;
            --button-bg-disabled: #44475a;
            --info-bg: #44475a;
            --info-border: #bd93f9;
            --breadcrumb-link: #8be9fd;
            --breadcrumb-link-hover: #ff79c6;
            --shadow-color: rgba(0,0,0,0.5);
        }

        body.nord-theme {
            /* Nord theme - Arctic, north-bluish color palette */
            --bg-primary: #2e3440;
            --bg-secondary: #3b4252;
            --text-primary: #eceff4;
            --text-secondary: #d8dee9;
            --text-tertiary: #e5e9f0;
            --border-color: #4c566a;
            --border-color-secondary: #434c5e;
            --button-bg: #5e81ac;
            --button-bg-hover: #81a1c1;
            --button-bg-disabled: #434c5e;
            --info-bg: #3b4252;
            --info-border: #88c0d0;
            --breadcrumb-link: #88c0d0;
            --breadcrumb-link-hover: #8fbcbb;
            --shadow-color: rgba(0,0,0,0.4);
        }

        body.solarized-dark-theme {
            /* Solarized Dark - Precision colors by Ethan Schoonover */
            --bg-primary: #002b36;
            --bg-secondary: #073642;
            --text-primary: #839496;
            --text-secondary: #586e75;
            --text-tertiary: #93a1a1;
            --border-color: #073642;
            --border-color-secondary: #586e75;
            --button-bg: #268bd2;
            --button-bg-hover: #2aa198;
            --button-bg-disabled: #073642;
            --info-bg: #073642;
            --info-border: #268bd2;
            --breadcrumb-link: #268bd2;
            --breadcrumb-link-hover: #2aa198;
            --shadow-color: rgba(0,0,0,0.5);
        }

        body.solarized-light-theme {
            /* Solarized Light - Precision colors by Ethan Schoonover */
            --bg-primary: #fdf6e3;
            --bg-secondary: #eee8d5;
            --text-primary: #657b83;
            --text-secondary: #93a1a1;
            --text-tertiary: #586e75;
            --border-color: #93a1a1;
            --border-color-secondary: #839496;
            --button-bg: #268bd2;
            --button-bg-hover: #2aa198;
            --button-bg-disabled: #93a1a1;
            --info-bg: #eee8d5;
            --info-border: #268bd2;
            --breadcrumb-link: #268bd2;
            --breadcrumb-link-hover: #2aa198;
            --shadow-color: rgba(0,0,0,0.1);
        }

        body.monokai-theme {
            /* Monokai - Classic TextMate theme */
            --bg-primary: #272822;
            --bg-secondary: #272822;
            --text-primary: #f8f8f2;
            --text-secondary: #75715e;
            --text-tertiary: #f8f8f2;
            --border-color: #49483e;
            --border-color-secondary: #75715e;
            --button-bg: #66d9ef;
            --button-bg-hover: #a6e22e;
            --button-bg-disabled: #49483e;
            --info-bg: #49483e;
            --info-border: #66d9ef;
            --breadcrumb-link: #66d9ef;
            --breadcrumb-link-hover: #a6e22e;
            --shadow-color: rgba(0,0,0,0.5);
        }

        body.one-dark-theme {
            /* One Dark - Atom's iconic theme */
            --bg-primary: #282c34;
            --bg-secondary: #21252b;
            --text-primary: #abb2bf;
            --text-secondary: #5c6370;
            --text-tertiary: #abb2bf;
            --border-color: #181a1f;
            --border-color-secondary: #3e4451;
            --button-bg: #61afef;
            --button-bg-hover: #98c379;
            --button-bg-disabled: #3e4451;
            --info-bg: #21252b;
            --info-border: #61afef;
            --breadcrumb-link: #61afef;
            --breadcrumb-link-hover: #56b6c2;
            --shadow-color: rgba(0,0,0,0.5);
        }

        body.gruvbox-theme {
            /* Gruvbox Dark - Retro groove colors */
            --bg-primary: #282828;
            --bg-secondary: #3c3836;
            --text-primary: #ebdbb2;
            --text-secondary: #a89984;
            --text-tertiary: #ebdbb2;
            --border-color: #504945;
            --border-color-secondary: #665c54;
            --button-bg: #458588;
            --button-bg-hover: #689d6a;
            --button-bg-disabled: #504945;
            --info-bg: #3c3836;
            --info-border: #458588;
            --breadcrumb-link: #83a598;
            --breadcrumb-link-hover: #8ec07c;
            --shadow-color: rgba(0,0,0,0.5);
        }

        body.tokyo-night-theme {
            /* Tokyo Night - Clean, elegant dark theme */
            --bg-primary: #1a1b26;
            --bg-secondary: #24283b;
            --text-primary: #c0caf5;
            --text-secondary: #565f89;
            --text-tertiary: #c0caf5;
            --border-color: #414868;
            --border-color-secondary: #565f89;
            --button-bg: #7aa2f7;
            --button-bg-hover: #7dcfff;
            --button-bg-disabled: #414868;
            --info-bg: #24283b;
            --info-border: #7aa2f7;
            --breadcrumb-link: #7aa2f7;
            --breadcrumb-link-hover: #7dcfff;
            --shadow-color: rgba(0,0,0,0.5);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background: var(--bg-primary);
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        #sidebar {
            width: 230px;
            min-width: 230px;
            max-width: 600px;
            background: var(--bg-secondary);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            position: relative;
        }

        #resize-handle {
            position: absolute;
            right: 0;
            top: 0;
            bottom: 0;
            width: 8px;
            cursor: col-resize;
            background: transparent;
            z-index: 1000;
            transition: background 0.2s;
        }

        #resize-handle:hover,
        #resize-handle.dragging {
            background: var(--info-border);
            opacity: 0.5;
        }

        #main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        #controls {
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        #controls h1 {
            font-size: 18px;
            margin-bottom: 8px;
            color: var(--text-primary);
        }

        .control-row {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .control-row-horizontal {
            display: flex;
            gap: 4px;
            align-items: flex-start;
        }

        p {
            color: var(--text-secondary);
            font-size: 12px;
            line-height: 1.0;
        }

        button {
            padding: 8px;
            background: var(--button-bg);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            min-width: 0;
        }

        button:hover {
            background: var(--button-bg-hover);
        }

        button:disabled {
            background: var(--button-bg-disabled);
            cursor: not-allowed;
        }

        #breadcrumb {
            font-size: 12px;
            color: var(--text-secondary);
            padding: 8px;
            background: var(--bg-primary);
            border-radius: 4px;
            word-wrap: break-word;
            flex: 1;
        }

        #breadcrumb a {
            color: var(--breadcrumb-link);
            cursor: pointer;
            text-decoration: underline;
        }

        #breadcrumb a:hover {
            color: var(--breadcrumb-link-hover);
        }

        #cy {
            flex: 1;
            background: var(--bg-secondary);
        }

        .section-label {
            color: var(--text-secondary);
            font-size: 12px;
            font-weight: bold;
            font-variant: small-caps;
            padding-top: 6px;
            border-bottom: 1px solid var(--text-secondary);
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 8px;
            flex: 1;
            min-width: 0;
        }

        .slider-container input[type="range"] {
            flex: 1;
            min-width: 0;
        }

        .slider-container span {
            color: var(--text-secondary);
            font-size: 12px;
            min-width: 20px;
            text-align: right;
        }

        .checkbox-label {
            color: var(--text-secondary);
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 6px;
            cursor: pointer;
        }

        .checkbox-label input[type="checkbox"] {
            cursor: pointer;
        }

        #themeSelector {
            padding: 8px 10px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            font-size: 13px;
            cursor: pointer;
            background: var(--bg-primary);
            color: var(--text-primary);
            width: 100%;
        }
    </style>
</head>
<body>
    <div id="sidebar">
        <div id="resize-handle"></div>
        <div id="controls">
            <!-- Header -->
            <h1 id="titleText"></h1>

            <!-- Navigation -->
            <div class="control-row">
                <div class="section-label">Navigation</div>
                <p>Click a node to zoom in.</p>
                <p>Click breadcrumb to go back.</p>
                <div id="breadcrumb" title="Breadcrumb trail"></div>
                <div class="control-row-horizontal">
                    <button id="resetBtn" onclick="reset()" title="Reset to top">&#x1f3e0;</button>
                    <button id="backBtn" onclick="goUp()" title="Go up one level">&#x2b06;&#xfe0f;</button>
                </div>
            </div>

            <!-- Layout -->
            <div class="control-row">
                <div class="section-label">Layout</div>
                <div class="control-row-horizontal">
                    <button onclick="applyLayout('dagre', 'cose')" title="Hierarchical layout">&#x2935;&#xfe0f;</button>
                    <button onclick="applyLayout('cose')" title="Force-directed layout">&#x2b50;</button>
                    <button onclick="cy.fit()" title="Fit view">&#x1f50d;</button>
                </div>
            </div>

            <!-- Appearance -->
            <div class="control-row">
                <div class="section-label">Appearance</div>
                <div class="control-row-horizontal" title="Theme">
                    <div>&#x1f3a8;</div>
                    <select id="themeSelector" onchange="changeTheme(this.value)">
                        <option value="light">Light</option>
                        <option value="dark">Dark</option>
                        <option value="dracula">Dracula</option>
                        <option value="nord">Nord</option>
                        <option value="solarized-dark">Solarized Dark</option>
                        <option value="solarized-light">Solarized Light</option>
                        <option value="monokai">Monokai</option>
                        <option value="one-dark">One Dark</option>
                        <option value="gruvbox">Gruvbox</option>
                        <option value="tokyo-night">Tokyo Night</option>
                        <option value="high-contrast">High Contrast</option>
                    </select>
                </div>
                <div class="control-row-horizontal" title="Node Size">
                    <div>&#x1f7e0;</div>
                    <div class="slider-container">
                        <input type="range" id="sizeSlider" min="20" max="100" value="50">
                        <span id="sizeValue">50</span>
                    </div>
                </div>
                <div class="control-row-horizontal" title="Font Size">
                    <div style="color: var(--text-secondary); font-weight: bold">&#x1f5da;</div>
                    <div class="slider-container">
                        <input type="range" id="fontSlider" min="8" max="40" value="12">
                        <span id="fontValue">12</span>
                    </div>
                </div>
            </div>

            <!-- Nodes and Edges -->
            <div class="control-row">
                <div class="control-row-horizontal">
                    <div style="margin-right: 10px">
                        <div class="section-label">Nodes</div>

                        <!-- Dependency visibility (shown only at top level) -->
                        <label id="vis-direct-label" class="checkbox-label" style="display: none;">
                            <input type="checkbox" id="vis-direct" checked>
                            <span>Direct</span>
                        </label>
                        <label id="vis-transitive-label" class="checkbox-label" style="display: none;">
                            <input type="checkbox" id="vis-transitive" checked>
                            <span>Transitive</span>
                        </label>

                        <!-- Code visibility (shown at package/class levels) -->
                        <label id="vis-public-label" class="checkbox-label" style="display: none;">
                            <input type="checkbox" id="vis-public" checked>
                            <span>Public</span>
                        </label>
                        <label id="vis-protected-label" class="checkbox-label" style="display: none;">
                            <input type="checkbox" id="vis-protected" checked>
                            <span>Protected</span>
                        </label>
                        <label id="vis-package-label" class="checkbox-label" style="display: none;">
                            <input type="checkbox" id="vis-package" checked>
                            <span>Package</span>
                        </label>
                        <label id="vis-private-label" class="checkbox-label" style="display: none;">
                            <input type="checkbox" id="vis-private" checked>
                            <span>Private</span>
                        </label>
                    </div>
                    <div>
                        <div class="section-label">Edges</div>
                        <label id="vis-inherits-label" class="checkbox-label" title="Structural 'is-a' relationship hierarchies">
                            <input type="checkbox" id="vis-inherits" checked>
                            <span>Inherits</span>
                        </label>
                        <label id="vis-uses-label" class="checkbox-label" title="Runtime dependencies (components/libraries), imports (packages/modules), usage (classes), calls (functions/methods)">
                            <input type="checkbox" id="vis-uses" checked>
                            <span>Uses</span>
                        </label>
                    </div>
                </div>
            </div>

            <!-- Visibility -->
            <div class="control-row">
                <div class="section-label">Visibility</div>
                <p>Right-click to hide a node.</p>
                <label class="checkbox-label">
                    <input type="checkbox" id="showHidden" onchange="toggleHiddenDisplay(this.checked)">
                    <span>&#x1fae3; Peek at hidden</span>
                </label>
                <button onclick="unhideAll()" title="Unhide all nodes">&#x1f441;&#xfe0f; Unhide All</button>
            </div>
        </div>
    </div>

    <div id="main-content">
        <div id="cy"></div>
    </div>

    <script>
        // All data injected as a single JSON blob
        const data = $DATA_JSON;

        const hierarchy = data.hierarchy;
        const functionData = data.functionData;
        const pythonDeps = data.external_deps;
        const pythonDepsDirect = data.external_deps_direct;
        const pythonDepsGraph = data.external_deps_graph;
        const ROOT = data.root_node_id;

        // Set page title
        document.getElementById('titleText').textContent = 'codezoom | ' + data.project_name;
        document.title = data.project_name + ' â€” codezoom';

        // Theme configuration
        const themes = {
            light: {
                nodeRoot: '#e74c3c',
                nodeRootText: '#ffffff',
                nodeClickable: '#f39c12',
                nodeClickableText: '#000000',
                nodeRegular: '#3498db',
                nodeRegularText: '#ffffff',
                nodeClass: '#9b59b6',
                nodeClassText: '#ffffff',
                nodeFunction: '#16a085',
                nodeFunctionText: '#ffffff',
                nodeMethod: '#e74c3c',
                nodeMethodText: '#ffffff',
                nodeExternalDirect: '#34495e',
                nodeExternalDirectText: '#ffffff',
                nodeExternalIndirect: '#95a5a6',
                nodeExternalIndirectText: '#000000',
                nodeHover: '#f1c40f',
                nodeHoverText: '#000000',
                edgeLine: '#95a5a6',
                edgeArrow: '#666',
                cyBackground: 'white',
                textOutlineDark: '#000000',   // Dark outline for light text
                textOutlineLight: '#ffffff'   // Light outline for dark text
            },
            dark: {
                nodeRoot: '#ff6b6b',
                nodeRootText: '#000000',
                nodeClickable: '#ffa500',
                nodeClickableText: '#000000',
                nodeRegular: '#4a9eff',
                nodeRegularText: '#000000',
                nodeClass: '#bd93f9',
                nodeClassText: '#000000',
                nodeFunction: '#50fa7b',
                nodeFunctionText: '#000000',
                nodeMethod: '#ff6b6b',
                nodeMethodText: '#000000',
                nodeExternalDirect: '#6272a4',
                nodeExternalDirectText: '#ffffff',
                nodeExternalIndirect: '#44475a',
                nodeExternalIndirectText: '#ffffff',
                nodeHover: '#f1fa8c',
                nodeHoverText: '#000000',
                edgeLine: '#6272a4',
                edgeArrow: '#888',
                cyBackground: '#1e1e1e',
                textOutlineDark: '#000000',
                textOutlineLight: '#ffffff'
            },
            'high-contrast': {
                nodeRoot: '#cc0000',
                nodeRootText: '#ffffff',
                nodeClickable: '#ff8800',
                nodeClickableText: '#000000',
                nodeRegular: '#0066cc',
                nodeRegularText: '#ffffff',
                nodeClass: '#7700cc',
                nodeClassText: '#ffffff',
                nodeFunction: '#008866',
                nodeFunctionText: '#ffffff',
                nodeMethod: '#cc0000',
                nodeMethodText: '#ffffff',
                nodeExternalDirect: '#000000',
                nodeExternalDirectText: '#ffffff',
                nodeExternalIndirect: '#666666',
                nodeExternalIndirectText: '#ffffff',
                nodeHover: '#ffff00',
                nodeHoverText: '#000000',
                edgeLine: '#666666',
                edgeArrow: '#333333',
                cyBackground: '#ffffff',
                textOutlineDark: '#000000',
                textOutlineLight: '#ffffff'
            },
            'dracula': {
                // Official Dracula color palette
                nodeRoot: '#ff5555',           // Dracula Red
                nodeRootText: '#282a36',       // Dracula Background (dark on light red)
                nodeClickable: '#ffb86c',      // Dracula Orange
                nodeClickableText: '#282a36',  // Dark text on orange
                nodeRegular: '#8be9fd',        // Dracula Cyan
                nodeRegularText: '#282a36',    // Dark text on cyan
                nodeClass: '#bd93f9',          // Dracula Purple
                nodeClassText: '#282a36',      // Dark text on purple
                nodeFunction: '#50fa7b',       // Dracula Green
                nodeFunctionText: '#282a36',   // Dark text on green
                nodeMethod: '#ff5555',         // Dracula Red
                nodeMethodText: '#282a36',     // Dark text on red
                nodeExternalDirect: '#6272a4', // Dracula Comment (blue-gray)
                nodeExternalDirectText: '#f8f8f2', // Light text on dark
                nodeExternalIndirect: '#44475a', // Dracula Current Line
                nodeExternalIndirectText: '#f8f8f2', // Light text on dark
                nodeHover: '#f1fa8c',          // Dracula Yellow
                nodeHoverText: '#282a36',      // Dark text on yellow
                edgeLine: '#6272a4',           // Dracula Comment
                edgeArrow: '#44475a',          // Dracula Current Line
                cyBackground: '#282a36',       // Dracula Background
                textOutlineDark: '#282a36',    // Dark outline (background color)
                textOutlineLight: '#f8f8f2'    // Light outline (foreground color)
            },
            'nord': {
                // Nord - Arctic, north-bluish color palette
                nodeRoot: '#bf616a',           // Nord Aurora Red
                nodeRootText: '#2e3440',       // Dark text on red
                nodeClickable: '#d08770',      // Nord Aurora Orange
                nodeClickableText: '#2e3440',  // Dark text on orange
                nodeRegular: '#5e81ac',        // Nord Frost Blue
                nodeRegularText: '#eceff4',    // Light text on blue
                nodeClass: '#b48ead',          // Nord Aurora Purple
                nodeClassText: '#2e3440',      // Dark text on purple
                nodeFunction: '#a3be8c',       // Nord Aurora Green
                nodeFunctionText: '#2e3440',   // Dark text on green
                nodeMethod: '#bf616a',         // Nord Aurora Red
                nodeMethodText: '#2e3440',     // Dark text on red
                nodeExternalDirect: '#4c566a', // Nord Polar Night
                nodeExternalDirectText: '#eceff4', // Light text on dark
                nodeExternalIndirect: '#3b4252', // Nord Polar Night
                nodeExternalIndirectText: '#eceff4', // Light text on dark
                nodeHover: '#ebcb8b',          // Nord Aurora Yellow
                nodeHoverText: '#2e3440',      // Dark text on yellow
                edgeLine: '#4c566a',           // Nord Polar Night
                edgeArrow: '#434c5e',          // Nord Polar Night
                cyBackground: '#2e3440',       // Nord Background
                textOutlineDark: '#2e3440',    // Dark outline
                textOutlineLight: '#eceff4'    // Light outline
            },
            'solarized-dark': {
                // Solarized Dark - Precision colors by Ethan Schoonover
                nodeRoot: '#dc322f',           // Solarized Red
                nodeRootText: '#fdf6e3',       // Light text on red
                nodeClickable: '#cb4b16',      // Solarized Orange
                nodeClickableText: '#fdf6e3',  // Light text on orange
                nodeRegular: '#268bd2',        // Solarized Blue
                nodeRegularText: '#fdf6e3',    // Light text on blue
                nodeClass: '#6c71c4',          // Solarized Violet
                nodeClassText: '#fdf6e3',      // Light text on violet
                nodeFunction: '#859900',       // Solarized Green
                nodeFunctionText: '#fdf6e3',   // Light text on green
                nodeMethod: '#dc322f',         // Solarized Red
                nodeMethodText: '#fdf6e3',     // Light text on red
                nodeExternalDirect: '#073642', // Solarized Base02
                nodeExternalDirectText: '#839496', // Medium text on dark
                nodeExternalIndirect: '#586e75', // Solarized Base01
                nodeExternalIndirectText: '#93a1a1', // Light text on medium
                nodeHover: '#b58900',          // Solarized Yellow
                nodeHoverText: '#002b36',      // Dark text on yellow
                edgeLine: '#586e75',           // Solarized Base01
                edgeArrow: '#073642',          // Solarized Base02
                cyBackground: '#002b36',       // Solarized Background
                textOutlineDark: '#002b36',    // Dark outline
                textOutlineLight: '#fdf6e3'    // Light outline
            },
            'solarized-light': {
                // Solarized Light - Precision colors by Ethan Schoonover
                nodeRoot: '#dc322f',           // Solarized Red
                nodeRootText: '#fdf6e3',       // Light text on red
                nodeClickable: '#cb4b16',      // Solarized Orange
                nodeClickableText: '#fdf6e3',  // Light text on orange
                nodeRegular: '#268bd2',        // Solarized Blue
                nodeRegularText: '#fdf6e3',    // Light text on blue
                nodeClass: '#6c71c4',          // Solarized Violet
                nodeClassText: '#fdf6e3',      // Light text on violet
                nodeFunction: '#859900',       // Solarized Green
                nodeFunctionText: '#fdf6e3',   // Light text on green
                nodeMethod: '#dc322f',         // Solarized Red
                nodeMethodText: '#fdf6e3',     // Light text on red
                nodeExternalDirect: '#93a1a1', // Solarized Base1
                nodeExternalDirectText: '#002b36', // Dark text on light
                nodeExternalIndirect: '#eee8d5', // Solarized Base2
                nodeExternalIndirectText: '#002b36', // Dark text on light
                nodeHover: '#b58900',          // Solarized Yellow
                nodeHoverText: '#002b36',      // Dark text on yellow
                edgeLine: '#93a1a1',           // Solarized Base1
                edgeArrow: '#839496',          // Solarized Base0
                cyBackground: '#fdf6e3',       // Solarized Background
                textOutlineDark: '#002b36',    // Dark outline
                textOutlineLight: '#fdf6e3'    // Light outline
            },
            'monokai': {
                // Monokai - Classic TextMate theme
                nodeRoot: '#f92672',           // Monokai Pink
                nodeRootText: '#272822',       // Dark text on pink
                nodeClickable: '#fd971f',      // Monokai Orange
                nodeClickableText: '#272822',  // Dark text on orange
                nodeRegular: '#66d9ef',        // Monokai Blue
                nodeRegularText: '#272822',    // Dark text on blue
                nodeClass: '#ae81ff',          // Monokai Purple
                nodeClassText: '#272822',      // Dark text on purple
                nodeFunction: '#a6e22e',       // Monokai Green
                nodeFunctionText: '#272822',   // Dark text on green
                nodeMethod: '#f92672',         // Monokai Pink
                nodeMethodText: '#272822',     // Dark text on pink
                nodeExternalDirect: '#49483e', // Monokai Dark Gray
                nodeExternalDirectText: '#f8f8f2', // Light text on dark
                nodeExternalIndirect: '#75715e', // Monokai Gray
                nodeExternalIndirectText: '#f8f8f2', // Light text on gray
                nodeHover: '#e6db74',          // Monokai Yellow
                nodeHoverText: '#272822',      // Dark text on yellow
                edgeLine: '#75715e',           // Monokai Gray
                edgeArrow: '#49483e',          // Monokai Dark Gray
                cyBackground: '#272822',       // Monokai Background
                textOutlineDark: '#272822',    // Dark outline
                textOutlineLight: '#f8f8f2'    // Light outline
            },
            'one-dark': {
                // One Dark - Atom's iconic theme
                nodeRoot: '#e06c75',           // One Dark Red
                nodeRootText: '#282c34',       // Dark text on red
                nodeClickable: '#d19a66',      // One Dark Orange
                nodeClickableText: '#282c34',  // Dark text on orange
                nodeRegular: '#61afef',        // One Dark Blue
                nodeRegularText: '#282c34',    // Dark text on blue
                nodeClass: '#c678dd',          // One Dark Purple
                nodeClassText: '#282c34',      // Dark text on purple
                nodeFunction: '#98c379',       // One Dark Green
                nodeFunctionText: '#282c34',   // Dark text on green
                nodeMethod: '#e06c75',         // One Dark Red
                nodeMethodText: '#282c34',     // Dark text on red
                nodeExternalDirect: '#3e4451', // One Dark Gray
                nodeExternalDirectText: '#abb2bf', // Light text on dark
                nodeExternalIndirect: '#21252b', // One Dark Darker
                nodeExternalIndirectText: '#abb2bf', // Light text on dark
                nodeHover: '#e5c07b',          // One Dark Yellow
                nodeHoverText: '#282c34',      // Dark text on yellow
                edgeLine: '#5c6370',           // One Dark Comment
                edgeArrow: '#3e4451',          // One Dark Gray
                cyBackground: '#282c34',       // One Dark Background
                textOutlineDark: '#282c34',    // Dark outline
                textOutlineLight: '#abb2bf'    // Light outline
            },
            'gruvbox': {
                // Gruvbox Dark - Retro groove colors
                nodeRoot: '#fb4934',           // Gruvbox Bright Red
                nodeRootText: '#282828',       // Dark text on red
                nodeClickable: '#fe8019',      // Gruvbox Bright Orange
                nodeClickableText: '#282828',  // Dark text on orange
                nodeRegular: '#83a598',        // Gruvbox Bright Blue
                nodeRegularText: '#282828',    // Dark text on blue
                nodeClass: '#d3869b',          // Gruvbox Bright Purple
                nodeClassText: '#282828',      // Dark text on purple
                nodeFunction: '#b8bb26',       // Gruvbox Bright Green
                nodeFunctionText: '#282828',   // Dark text on green
                nodeMethod: '#fb4934',         // Gruvbox Bright Red
                nodeMethodText: '#282828',     // Dark text on red
                nodeExternalDirect: '#504945', // Gruvbox Dark Gray
                nodeExternalDirectText: '#ebdbb2', // Light text on dark
                nodeExternalIndirect: '#3c3836', // Gruvbox Darker
                nodeExternalIndirectText: '#ebdbb2', // Light text on dark
                nodeHover: '#fabd2f',          // Gruvbox Bright Yellow
                nodeHoverText: '#282828',      // Dark text on yellow
                edgeLine: '#665c54',           // Gruvbox Gray
                edgeArrow: '#504945',          // Gruvbox Dark Gray
                cyBackground: '#282828',       // Gruvbox Background
                textOutlineDark: '#282828',    // Dark outline
                textOutlineLight: '#ebdbb2'    // Light outline
            },
            'tokyo-night': {
                // Tokyo Night - Clean, elegant dark theme
                nodeRoot: '#f7768e',           // Tokyo Night Red
                nodeRootText: '#1a1b26',       // Dark text on red
                nodeClickable: '#ff9e64',      // Tokyo Night Orange
                nodeClickableText: '#1a1b26',  // Dark text on orange
                nodeRegular: '#7aa2f7',        // Tokyo Night Blue
                nodeRegularText: '#1a1b26',    // Dark text on blue
                nodeClass: '#bb9af7',          // Tokyo Night Purple
                nodeClassText: '#1a1b26',      // Dark text on purple
                nodeFunction: '#9ece6a',       // Tokyo Night Green
                nodeFunctionText: '#1a1b26',   // Dark text on green
                nodeMethod: '#f7768e',         // Tokyo Night Red
                nodeMethodText: '#1a1b26',     // Dark text on red
                nodeExternalDirect: '#414868', // Tokyo Night Dark
                nodeExternalDirectText: '#c0caf5', // Light text on dark
                nodeExternalIndirect: '#24283b', // Tokyo Night Darker
                nodeExternalIndirectText: '#c0caf5', // Light text on dark
                nodeHover: '#e0af68',          // Tokyo Night Yellow
                nodeHoverText: '#1a1b26',      // Dark text on yellow
                edgeLine: '#565f89',           // Tokyo Night Comment
                edgeArrow: '#414868',          // Tokyo Night Dark
                cyBackground: '#1a1b26',       // Tokyo Night Background
                textOutlineDark: '#1a1b26',    // Dark outline
                textOutlineLight: '#c0caf5'    // Light outline
            }
        };

        // Theme state
        let currentTheme = localStorage.getItem('codezoom_theme') || 'light';

        // Navigation state
        let currentNode = ROOT;
        const history = [ROOT];

        // Hidden nodes tracking
        const userHiddenNodes = new Set();

        let cy = null;

        function getBorderStyleForVisibility(visibility) {
            // Map visibility to border style (UML convention)
            // public: solid, protected: dotted, package: double, private: dashed
            if (!visibility) return 'solid';  // Default to solid
            switch (visibility) {
                case 'public': return 'solid';
                case 'protected': return 'dotted';
                case 'package': return 'double';
                case 'private': return 'dashed';
                default: return 'solid';
            }
        }

        // Helper to determine if a color is light or dark
        function isLightColor(color) {
            if (!color) return false;
            const hex = color.replace('#', '');
            if (hex.length === 3) {
                const r = parseInt(hex[0] + hex[0], 16);
                const g = parseInt(hex[1] + hex[1], 16);
                const b = parseInt(hex[2] + hex[2], 16);
                return (r + g + b) / 3 > 127;
            }
            const r = parseInt(hex.substr(0, 2), 16);
            const g = parseInt(hex.substr(2, 2), 16);
            const b = parseInt(hex.substr(4, 2), 16);
            return (r + g + b) / 3 > 127;
        }

        function applyColorsToNode(node, colors) {
            const d = node.data();
            const type = d.nodeType || 'regular'; // Default to regular

            // Simple type-to-color mapping
            const colorMap = {
                'root': [colors.nodeRoot, colors.nodeRootText],
                'clickable': [colors.nodeClickable, colors.nodeClickableText],
                'regular': [colors.nodeRegular, colors.nodeRegularText],
                'class': [colors.nodeClass, colors.nodeClassText],
                'function': [colors.nodeFunction, colors.nodeFunctionText],
                'method': [colors.nodeMethod, colors.nodeMethodText],
                'external-direct': [colors.nodeExternalDirect, colors.nodeExternalDirectText],
                'external-indirect': [colors.nodeExternalIndirect, colors.nodeExternalIndirectText],
            };

            const [bgColor, textColor] = colorMap[type] || [colors.nodeRegular, colors.nodeRegularText];

            // Choose outline color based on text color brightness
            const outlineColor = isLightColor(textColor) ? colors.textOutlineDark : colors.textOutlineLight;

            node.style('background-color', bgColor);
            node.style('color', textColor);
            node.style('text-outline-color', outlineColor);

            if (d.borderWidth) node.style('border-width', d.borderWidth);
            if (d.borderColor) node.style('border-color', d.borderColor);

            // Apply border style based on visibility
            const borderStyle = getBorderStyleForVisibility(d.visibility);
            node.style('border-style', borderStyle);
        }

        function applyNodeColors() {
            if (!cy) return;
            const colors = themes[currentTheme];

            cy.nodes().forEach(node => {
                applyColorsToNode(node, colors);
            });
        }

        function initCytoscape() {
            if (cy) cy.destroy();

            const colors = themes[currentTheme];

            cy = cytoscape({
                container: document.getElementById('cy'),
                elements: buildGraphData(currentNode),
                style: [
                    {
                        selector: 'node',
                        style: {
                            'content': 'data(label)',
                            'width': 50,
                            'height': 50,
                            'padding': '5px',
                            'text-opacity': 1,
                            'text-wrap': 'wrap',
                            'font-size': '12px',
                            'font-weight': 'bold',
                            'text-valign': 'center',
                            'text-halign': 'center',
                            'background-color': colors.nodeRegular,
                            'border-width': 2,
                            'border-color': '#2980b9',
                            'background-opacity': 0.9,
                            'text-outline-width': 1.5,
                            'text-outline-color': colors.textOutlineDark,
                        }
                    },
                    {
                        selector: 'edge',
                        style: {
                            'curve-style': 'straight',
                            'target-arrow-shape': 'triangle',
                            'target-arrow-color': colors.edgeArrow,
                            'target-arrow-fill': 'filled',
                            'arrow-scale': 1.5,
                            'line-color': colors.edgeLine,
                            'width': 2,
                            'opacity': 0.7,
                        }
                    },
                    {
                        selector: 'edge[type="inherits"]',
                        style: {
                            'target-arrow-shape': 'vee',
                            'target-arrow-color': colors.nodeRoot, // !!!
                            'line-color': colors.nodeRoot, // !!!
                            'line-style': 'dashed',
                            'width': 3,
                            'z-index': 10,
                        }
                    },
                    {
                        selector: 'node.hover',
                        style: {
                            'background-color': colors.nodeHover,
                            'color': colors.nodeHoverText,
                            'border-color': '#d68910',
                        }
                    },
                ],
                layout: {
                    name: 'cose',
                    directed: true,
                    animate: true,
                    animationDuration: 500,
                },
                wheelSensitivity: 0.05,
                minZoom: 0.1,
                maxZoom: 3,
            });

            // Handle hover state
            cy.on('mouseover', 'node', function(evt) {
                const node = evt.target;
                const colors = themes[currentTheme];
                const outlineColor = isLightColor(colors.nodeHoverText) ? colors.textOutlineDark : colors.textOutlineLight;
                node.style({
                    'background-color': colors.nodeHover,
                    'color': colors.nodeHoverText,
                    'border-color': colors.nodeHover,
                    'text-outline-color': outlineColor
                });
            });

            cy.on('mouseout', 'node', function(evt) {
                const node = evt.target;
                const colors = themes[currentTheme];
                applyColorsToNode(node, colors);
            });

            cy.on('tap', 'node', function(evt) {
                const node = evt.target;
                const nodeId = node.id();

                const hasChildren = hierarchy[nodeId] && hierarchy[nodeId].children && hierarchy[nodeId].children.length > 0;
                const hasFunctions = functionData[nodeId] && Object.keys(functionData[nodeId]).length > 0;

                let isClickableClass = false;
                if (nodeId.includes(':')) {
                    const lastColonIdx = nodeId.lastIndexOf(':');
                    const moduleId = nodeId.substring(0, lastColonIdx);
                    const symbolPath = nodeId.substring(lastColonIdx + 1);

                    // Check if this symbol is a class with children (could be inner class)
                    const symbolInfo = findSymbol(moduleId, symbolPath);
                    if (symbolInfo) {
                        isClickableClass = symbolInfo.type === 'class' && symbolInfo.methods && Object.keys(symbolInfo.methods).length > 0;
                    }
                }

                if (hasChildren || hasFunctions || isClickableClass) {
                    drillInto(nodeId);
                }
            });

            // Right-click to hide/unhide nodes
            cy.on('cxttap', 'node', function(evt) {
                const node = evt.target;
                const nodeId = node.id();

                if (userHiddenNodes.has(nodeId)) {
                    // Unhide
                    userHiddenNodes.delete(nodeId);
                    node.removeClass('user-hidden');
                    node.style('display', 'element');
                    node.style('opacity', 1);
                } else {
                    // Hide
                    userHiddenNodes.add(nodeId);
                    node.addClass('user-hidden');
                    updateHiddenDisplay();
                }
            });

            setTimeout(() => {
                applyNodeColors();
                applyVisibilityFilter();  // Apply filter after layout
                cy.fit();
            }, 100);
        }

        function findSymbol(moduleId, symbolPath) {
            // Navigate through nested classes to find a symbol
            // symbolPath can be:
            //  - "ClassName" (top-level class)
            //  - "OuterClass.InnerClass" (nested class)
            //  - "ClassName.method(args)" (method in class)
            //  - "OuterClass.InnerClass.method(args)" (method in nested class)
            if (!functionData[moduleId]) return null;

            // First, try direct lookup (for top-level classes/functions)
            if (functionData[moduleId][symbolPath]) {
                return functionData[moduleId][symbolPath];
            }

            // For nested symbols, navigate through the structure
            // Split into potential class path and member name
            const parts = symbolPath.split('.');

            // Start with the top-level class
            let current = functionData[moduleId][parts[0]];
            if (!current) return null;

            if (parts.length === 1) return current;

            // Navigate through potential nested classes and methods
            // Try to find the longest matching qualified name first
            for (let i = 1; i < parts.length; i++) {
                if (!current.methods) return null;

                // Try qualified name first (for inner classes like "Outer.Inner")
                const qualifiedName = parts.slice(0, i + 1).join('.');
                if (current.methods[qualifiedName]) {
                    current = current.methods[qualifiedName];
                    continue;
                }

                // Try simple name (for methods like "method()")
                const simpleName = parts.slice(i).join('.');
                if (current.methods[simpleName]) {
                    return current.methods[simpleName];
                }

                return null;
            }

            return current;
        }

        function buildGraphData(nodeId) {
            const elements = [];

            // Method-level nodes (format: "moduleId:symbolPath")
            // symbolPath can be a class, inner class, or method
            if (nodeId.includes(':')) {
                const lastColonIdx = nodeId.lastIndexOf(':');
                const moduleId = nodeId.substring(0, lastColonIdx);
                const symbolPath = nodeId.substring(lastColonIdx + 1);

                // Find the symbol (could be nested)
                const symbol = findSymbol(moduleId, symbolPath);

                // If it's a class with methods/children, show them
                if (symbol && symbol.type === 'class' && symbol.methods) {
                    return buildMethodGraph(moduleId, symbolPath);
                }
            }

            // Top-level: show external dependencies
            if (nodeId === ROOT && history.length === 1 && pythonDeps.length > 0) {
                const seenEdges = new Set();

                pythonDeps.forEach(dep => {
                    const isDirect = pythonDepsDirect.includes(dep);
                    elements.push({
                        data: {
                            id: 'ext-dep-' + dep,
                            label: dep.replace(':', '\n'),
                            nodeType: isDirect ? 'external-direct' : 'external-indirect',
                            borderWidth: isDirect ? 2 : 1,
                            borderColor: isDirect ? '#2c3e50' : '#7f8c8d',
                        }
                    });
                });

                pythonDepsDirect.forEach(dep => {
                    const edgeId = ROOT + '->ext-dep-' + dep;
                    if (!seenEdges.has(edgeId)) {
                        elements.push({ data: { id: edgeId, source: ROOT, target: 'ext-dep-' + dep, type: 'dependency' } });
                        seenEdges.add(edgeId);
                    }
                });

                pythonDeps.forEach(dep => {
                    if (pythonDepsGraph[dep]) {
                        pythonDepsGraph[dep].forEach(depDep => {
                            if (pythonDeps.includes(depDep)) {
                                const edgeId = 'ext-dep-' + dep + '->ext-dep-' + depDep;
                                if (!seenEdges.has(edgeId)) {
                                    elements.push({ data: { id: edgeId, source: 'ext-dep-' + dep, target: 'ext-dep-' + depDep, type: 'dependency' } });
                                    seenEdges.add(edgeId);
                                }
                            }
                        });
                    }
                });

                // Root node (drillable)
                elements.push({
                    data: {
                        id: ROOT,
                        label: data.project_name,
                        nodeType: 'root',
                        borderWidth: 3,
                        borderColor: '#c0392b',
                    }
                });

                return elements;
            }

            // Regular hierarchy node
            const node = hierarchy[nodeId];
            if (!node) return elements;

            const children = node.children || [];
            const hasFunctions = functionData[nodeId] && Object.keys(functionData[nodeId]).length > 0;

            // Leaf module with function data only (no sub-package children)
            if (hasFunctions && children.length === 0) {
                return buildFunctionGraph(nodeId);
            }

            // Build child package nodes
            const childSet = new Set(children);

            if (children.length > 0) {
                children.forEach(childId => {
                    const childNode = hierarchy[childId];
                    const hasChildren = childNode && childNode.children && childNode.children.length > 0;
                    const childHasFunctions = functionData[childId];
                    const isClickable = hasChildren || childHasFunctions;

                    elements.push({
                        data: {
                            id: childId,
                            label: childId.split('.').pop(),
                            nodeType: isClickable ? 'clickable' : 'regular',
                            borderWidth: isClickable ? 3 : 2,
                            borderColor: isClickable ? '#d68910' : '#2980b9',
                        }
                    });
                });

                children.forEach(childId => {
                    const childNode = hierarchy[childId];
                    if (childNode && childNode.imports_to) {
                        childNode.imports_to.forEach(targetId => {
                            if (childSet.has(targetId) && childId !== targetId) {
                                const edgeId = childId + '->' + targetId;
                                if (!elements.find(el => el.data.id === edgeId)) {
                                    elements.push({ data: { id: edgeId, source: childId, target: targetId, type: 'import' } });
                                }
                            }
                        });
                    }
                });
            }

            // Also show symbols (classes) alongside sub-package children
            if (hasFunctions) {
                const functions = functionData[nodeId];
                Object.entries(functions).forEach(([name, info]) => {
                    const nodeFullId = nodeId + ':' + name;
                    const hasMethodsOrCalls = (info.methods && Object.keys(info.methods).length > 0) || (info.calls && info.calls.length > 0);

                    elements.push({
                        data: {
                            id: nodeFullId,
                            label: name,
                            nodeType: info.type === 'class' ? 'class' : 'function',
                            borderWidth: hasMethodsOrCalls ? 3 : 2,
                            borderColor: info.type === 'class' ? '#8e44ad' : '#117a65',
                            hasChildren: info.type === 'class' && info.methods && Object.keys(info.methods).length > 0,
                            visibility: info.visibility || null,
                        }
                    });
                });

                // Add class-level dependency edges from jdeps
                const classDeps = hierarchy[nodeId] && hierarchy[nodeId].class_deps;
                if (classDeps) {
                    const nodeIds = new Set(elements.filter(e => !e.data.source).map(e => e.data.id));

                    Object.entries(classDeps).forEach(([srcClass, targets]) => {
                        const srcId = nodeId + ':' + srcClass;
                        if (!nodeIds.has(srcId)) return;
                        targets.forEach(target => {
                            // target with '.' is a package node ID; without is a same-package class
                            const tgtId = target.includes('.') ? target : nodeId + ':' + target;
                            if (!nodeIds.has(tgtId) || srcId === tgtId) return;
                            const edgeId = srcId + '->dep-' + target;
                            if (!elements.find(el => el.data.id === edgeId)) {
                                elements.push({ data: { id: edgeId, source: srcId, target: tgtId, type: 'dependency' } });
                            }
                        });
                    });
                }
            }

            return elements;
        }

        function buildFunctionGraph(moduleId) {
            const elements = [];
            const functions = functionData[moduleId];
            if (!functions) return elements;

            Object.entries(functions).forEach(([name, info]) => {
                const hasMethodsOrCalls = (info.methods && Object.keys(info.methods).length > 0) || (info.calls && info.calls.length > 0);
                let borderWidth = hasMethodsOrCalls ? 3 : 2;

                elements.push({
                    data: {
                        id: moduleId + ':' + name,
                        label: name,
                        nodeType: info.type === 'class' ? 'class' : 'function',
                        borderWidth: borderWidth,
                        borderColor: info.type === 'class' ? '#8e44ad' : '#117a65',
                        hasChildren: info.type === 'class' && info.methods && Object.keys(info.methods).length > 0,
                        visibility: info.visibility || null,
                    }
                });
            });

            Object.entries(functions).forEach(([name, info]) => {
                if (info.calls && info.calls.length > 0) {
                    info.calls.forEach(calledName => {
                        // Bytecode analysis gives us exact signatures
                        if (functions[calledName]) {
                            const edgeId = moduleId + ':' + name + '->' + calledName;
                            if (!elements.find(el => el.data.id === edgeId)) {
                                elements.push({ data: { id: edgeId, source: moduleId + ':' + name, target: moduleId + ':' + calledName, type: 'call' } });
                            }
                        }
                    });
                }

                if (info.inherits && info.inherits.length > 0) {
                    info.inherits.forEach(parentName => {
                        if (functions[parentName]) {
                            const edgeId = moduleId + ':' + name + '-inherits-' + parentName;
                            if (!elements.find(el => el.data.id === edgeId)) {
                                elements.push({ data: { id: edgeId, source: moduleId + ':' + name, target: moduleId + ':' + parentName, type: 'inherits' } });
                            }
                        }
                    });
                }
            });

            // Add class-level dependency edges from jdeps
            const classDeps = hierarchy[moduleId] && hierarchy[moduleId].class_deps;
            if (classDeps) {
                const nodeIds = new Set(elements.filter(e => !e.data.source).map(e => e.data.id));

                Object.entries(classDeps).forEach(([srcClass, targets]) => {
                    const srcId = moduleId + ':' + srcClass;
                    if (!nodeIds.has(srcId)) return;
                    targets.forEach(target => {
                        // target with '.' is a package node ID; without is a same-package class
                        const tgtId = target.includes('.') ? target : moduleId + ':' + target;
                        if (!nodeIds.has(tgtId) || srcId === tgtId) return;
                        const edgeId = srcId + '->dep-' + target;
                        if (!elements.find(el => el.data.id === edgeId)) {
                            elements.push({ data: { id: edgeId, source: srcId, target: tgtId, type: 'dependency' } });
                        }
                    });
                });
            }

            return elements;
        }

        function buildMethodGraph(moduleId, symbolPath) {
            // symbolPath can be "ClassName" or "OuterClass.InnerClass"
            const elements = [];

            const classInfo = findSymbol(moduleId, symbolPath);
            if (!classInfo) return elements;

            const methods = classInfo.methods || {};

            Object.entries(methods).forEach(([childName, childInfo]) => {
                // Child can be a method or nested class
                const fullChildName = childName.includes('.') ? childName : `${symbolPath}.${childName}`;

                // For display: show just the simple name (last part after final dot)
                let displayLabel = childName;
                if (childInfo.type === 'class' && childName.includes('.')) {
                    // Inner class: show just "InnerClass" not "OuterClass.InnerClass"
                    const parts = childName.split('.');
                    displayLabel = parts[parts.length - 1];
                }

                elements.push({
                    data: {
                        id: moduleId + ':' + fullChildName,
                        label: displayLabel,
                        nodeType: childInfo.type === 'class' ? 'class' : 'method',
                        borderWidth: 2,
                        borderColor: childInfo.type === 'class' ? '#8e44ad' : '#c0392b',
                        visibility: childInfo.visibility || null,
                        hasChildren: childInfo.type === 'class' && childInfo.methods && Object.keys(childInfo.methods).length > 0,
                    }
                });
            });

            Object.entries(methods).forEach(([childName, childInfo]) => {
                if (childInfo.calls && childInfo.calls.length > 0) {
                    const fullChildName = childName.includes('.') ? childName : `${symbolPath}.${childName}`;
                    childInfo.calls.forEach(calledName => {
                        // Bytecode analysis gives us exact signatures, so just check if it exists
                        if (methods[calledName]) {
                            const fullCalledName = calledName.includes('.') ? calledName : `${symbolPath}.${calledName}`;
                            const edgeId = moduleId + ':' + fullChildName + '->' + calledName;
                            if (!elements.find(el => el.data.id === edgeId)) {
                                elements.push({ data: { id: edgeId, source: moduleId + ':' + fullChildName, target: moduleId + ':' + fullCalledName, type: 'call' } });
                            }
                        }
                    });
                }
            });

            return elements;
        }

        function drillInto(nodeId) {
            if (!nodeId.includes(':') && !hierarchy[nodeId]) return;
            currentNode = nodeId;
            history.push(nodeId);
            updateUI();
        }

        function goUp() {
            if (history.length > 1) {
                history.pop();
                currentNode = history[history.length - 1];
                updateUI();
            }
        }

        function reset() {
            currentNode = ROOT;
            history.length = 1;
            history[0] = ROOT;
            updateUI();
        }

        function updateHiddenDisplay() {
            if (!cy) return;
            const showHidden = document.getElementById('showHidden').checked;

            cy.nodes('.user-hidden').forEach(node => {
                if (showHidden) {
                    // Translucent mode - show hidden nodes with visual indication
                    node.style('display', 'element');
                    node.style('opacity', 0.3);
                } else {
                    // Completely hidden
                    node.style('display', 'none');
                }
            });
        }

        function toggleHiddenDisplay(showHidden) {
            updateHiddenDisplay();
            // Reapply visibility filter after toggling hidden display
            applyVisibilityFilter();
        }

        function unhideAll() {
            userHiddenNodes.clear();
            if (cy) {
                cy.nodes('.user-hidden').forEach(node => {
                    node.removeClass('user-hidden');
                    node.style('display', 'element');
                    node.style('opacity', 1);
                });
            }
        }

        function getZoomContext() {
            // Determine what level we're viewing
            if (currentNode === ROOT && history.length === 1 && pythonDeps.length > 0) {
                return 'dependencies';
            } else if (currentNode.includes(':')) {
                // At class or method level
                const lastColonIdx = currentNode.lastIndexOf(':');
                const classPath = currentNode.substring(lastColonIdx + 1);
                if (classPath.includes('.')) {
                    return 'methods';  // Viewing methods of a class
                } else {
                    return 'members';  // Viewing members (could be methods or classes)
                }
            } else {
                return 'packages';  // Viewing packages/modules
            }
        }

        function detectLanguageFeatures() {
            // Detect which visibility levels are actually used in the project
            const usedVisibilities = new Set();

            // Check all symbols in functionData
            for (const moduleId in functionData) {
                const symbols = functionData[moduleId];
                for (const symbolName in symbols) {
                    const symbol = symbols[symbolName];
                    if (symbol.visibility) {
                        usedVisibilities.add(symbol.visibility);
                    }
                    // Check methods too
                    if (symbol.methods) {
                        for (const methodName in symbol.methods) {
                            const method = symbol.methods[methodName];
                            if (method.visibility) {
                                usedVisibilities.add(method.visibility);
                            }
                        }
                    }
                }
            }

            return {
                hasProtected: usedVisibilities.has('protected'),
                hasPackage: usedVisibilities.has('package'),
            };
        }

        function updateVisibilityCheckboxes() {
            const context = getZoomContext();
            const languageFeatures = detectLanguageFeatures();

            // Hide all checkboxes first
            document.getElementById('vis-direct-label').style.display = 'none';
            document.getElementById('vis-transitive-label').style.display = 'none';
            document.getElementById('vis-public-label').style.display = 'none';
            document.getElementById('vis-protected-label').style.display = 'none';
            document.getElementById('vis-package-label').style.display = 'none';
            document.getElementById('vis-private-label').style.display = 'none';

            // Show relevant checkboxes based on context
            if (context === 'dependencies') {
                document.getElementById('vis-direct-label').style.display = 'block';
                document.getElementById('vis-transitive-label').style.display = 'block';
            } else {
                // Package/class/method views - show code visibility
                document.getElementById('vis-public-label').style.display = 'block';

                // Only show protected/package if they're actually used in the project
                if (languageFeatures.hasProtected) {
                    document.getElementById('vis-protected-label').style.display = 'block';
                }
                if (languageFeatures.hasPackage) {
                    document.getElementById('vis-package-label').style.display = 'block';
                }

                document.getElementById('vis-private-label').style.display = 'block';
            }
        }

        function shouldShowNode(node, context) {
            const nodeId = node.id();
            const nodeData = node.data();

            // Dependencies context
            if (context === 'dependencies') {
                if (nodeId.startsWith('ext-dep-')) {
                    const depName = nodeId.substring(8);  // Remove 'ext-dep-' prefix
                    const isDirect = pythonDepsDirect.includes(depName);

                    // Check visibility checkboxes
                    const showDirect = document.getElementById('vis-direct').checked;
                    const showTransitive = document.getElementById('vis-transitive').checked;

                    if (isDirect && !showDirect) return false;
                    if (!isDirect && !showTransitive) return false;
                }
                return true;  // Show project root
            }

            // Get visibility checkbox states
            const showPublic = document.getElementById('vis-public').checked;
            const showProtected = document.getElementById('vis-protected').checked;
            const showPackage = document.getElementById('vis-package').checked;
            const showPrivate = document.getElementById('vis-private').checked;

            // Check symbol visibility for classes/methods
            if (nodeId.includes(':')) {
                const lastColonIdx = nodeId.lastIndexOf(':');
                const moduleId = nodeId.substring(0, lastColonIdx);
                const symbolPath = nodeId.substring(lastColonIdx + 1);

                // Extract visibility from function data (handles nested classes)
                const symbolInfo = findSymbol(moduleId, symbolPath);
                const visibility = symbolInfo ? symbolInfo.visibility : null;

                if (visibility) {
                    // Filter based on visibility checkboxes
                    if (visibility === 'public' && !showPublic) return false;
                    if (visibility === 'protected' && !showProtected) return false;
                    if (visibility === 'package' && !showPackage) return false;
                    if (visibility === 'private' && !showPrivate) return false;
                }
            }

            // Module/package visibility - check if exported
            // (is_exported is set by language-specific extractors)
            if (!nodeId.includes(':') && hierarchy[nodeId]) {
                const isExported = hierarchy[nodeId].is_exported !== false;
                if (isExported && !showPublic) {
                    return false;  // Hide public/exported packages if public is unchecked
                }
                if (!isExported && !showPrivate) {
                    return false;  // Hide internal/private packages if private is unchecked
                }
            }

            return true;
        }

        function applyVisibilityFilter() {
            if (!cy) return;

            const context = getZoomContext();

            // Update which checkboxes are shown
            updateVisibilityCheckboxes();

            // Apply node filter
            cy.nodes().forEach(node => {
                // Skip user-hidden nodes (they're handled separately)
                if (node.hasClass('user-hidden')) return;

                if (shouldShowNode(node, context)) {
                    node.style('display', 'element');
                } else {
                    node.style('display', 'none');
                }
            });

            // Apply edge filter
            const showInherits = document.getElementById('vis-inherits').checked;
            const showUses = document.getElementById('vis-uses').checked;

            cy.edges().forEach(edge => {
                const edgeType = edge.data('type');
                let shouldShow = true;

                if (edgeType === 'inherits' && !showInherits) shouldShow = false;
                if (edgeType === 'dependency' && !showUses) shouldShow = false;
                if (edgeType === 'call' && !showUses) shouldShow = false;
                if (edgeType === 'import' && !showUses) shouldShow = false;

                if (shouldShow) {
                    edge.style('display', 'element');
                } else {
                    edge.style('display', 'none');
                }
            });
        }

        function updateUI() {
            updateBreadcrumb();
            updateBackButton();
            initCytoscape();
            // applyVisibilityFilter is now called inside initCytoscape's setTimeout
        }

        function updateBreadcrumb() {
            const breadcrumb = document.getElementById('breadcrumb');
            const parts = [];

            history.forEach((nodeId, idx) => {
                if (idx === 0) {
                    // Root: show project name
                    const label = data.project_name;
                    if (history.length === 1) {
                        parts.push('<strong>' + label + '</strong>');
                    } else {
                        parts.push('<a onclick="jumpTo(0)">' + label + '</a>');
                    }
                    return;
                }

                const prevNodeId = history[idx - 1];
                let label = '';
                let separator = '';

                // Determine incremental label and separator based on node type
                if (nodeId.includes(':')) {
                    // Symbol node (class/method): format is "package:Symbol"
                    const colonIdx = nodeId.lastIndexOf(':');
                    const symbolPart = nodeId.substring(colonIdx + 1);

                    if (prevNodeId.includes(':')) {
                        // Previous was also a symbol - check for nesting
                        const prevColonIdx = prevNodeId.lastIndexOf(':');
                        const prevSymbolPath = prevNodeId.substring(prevColonIdx + 1);

                        if (symbolPart.startsWith(prevSymbolPath + '.')) {
                            // Nested symbol (e.g., "Class" -> "Class.method")
                            label = symbolPart.substring(prevSymbolPath.length + 1);
                            separator = '.';
                        } else {
                            // Different symbol at same level
                            label = symbolPart;
                            separator = ':';
                        }
                    } else {
                        // Previous was a package, now showing a symbol
                        label = symbolPart;
                        separator = ':';
                    }
                } else {
                    // Package node
                    if (nodeId.startsWith(prevNodeId + '.')) {
                        // Incremental package (e.g., "org.foo" -> "org.foo.bar")
                        label = nodeId.substring(prevNodeId.length + 1);
                        separator = '.';
                    } else {
                        // First level or different branch
                        label = nodeId;
                        separator = ' &rsaquo; ';
                    }
                }

                // Build HTML
                const isLast = idx === history.length - 1;
                const html = isLast
                    ? '<strong>' + label + '</strong>'
                    : '<a onclick="jumpTo(' + idx + ')">' + label + '</a>';

                parts.push(separator + html);
            });

            breadcrumb.innerHTML = parts.join('');
        }

        function jumpTo(idx) {
            history.length = idx + 1;
            currentNode = history[history.length - 1];
            updateUI();
        }

        function updateBackButton() {
            document.getElementById('backBtn').disabled = history.length <= 1;
        }

        function applyLayout(name, fallback) {
            try {
                cy.layout({name: name}).run();
            } catch(e) {
                if (fallback) cy.layout({name: fallback}).run();
            }
        }

        function applyTheme(theme) {
            // Validate theme exists
            if (!themes[theme]) {
                console.warn(`Theme "${theme}" not found, falling back to light`);
                theme = 'light';
            }

            currentTheme = theme;

            // Update body class for CSS variables
            document.body.className = ''; // Clear all theme classes
            if (theme !== 'light') {
                document.body.classList.add(theme + '-theme');
            }

            // Update Cytoscape colors if graph exists
            if (cy) {
                const colors = themes[theme];

                // Update container background
                document.getElementById('cy').style.background = colors.cyBackground;

                // Update node hover styles
                cy.style()
                    .selector('node.hover').style({
                        'background-color': colors.nodeHover,
                        'color': colors.nodeHoverText
                    })
                    .update();

                // Reapply node-specific colors (this handles text colors too)
                applyNodeColors();
            }

            // Update dropdown selection
            const selector = document.getElementById('themeSelector');
            if (selector) {
                selector.value = theme;
            }

            // Persist to localStorage
            localStorage.setItem('codezoom_theme', theme);
        }

        function changeTheme(theme) {
            applyTheme(theme);
        }

        // Node size slider
        const sizeSlider = document.getElementById('sizeSlider');
        const sizeValue = document.getElementById('sizeValue');

        sizeSlider.addEventListener('input', function() {
            const newSize = this.value;
            sizeValue.textContent = newSize;
            if (cy) {
                cy.nodes().style('width', newSize);
                cy.nodes().style('height', newSize);
            }
        });

        // Font size slider
        const fontSlider = document.getElementById('fontSlider');
        const fontValue = document.getElementById('fontValue');

        fontSlider.addEventListener('input', function() {
            const newFontSize = this.value;
            fontValue.textContent = newFontSize;
            if (cy) {
                cy.nodes().style('font-size', newFontSize + 'px');
            }
        });

        // Visibility checkboxes
        const visibilityCheckboxes = [
            'vis-direct', 'vis-transitive',
            'vis-public', 'vis-protected', 'vis-package', 'vis-private',
            'vis-inherits', 'vis-uses'
        ];
        visibilityCheckboxes.forEach(id => {
            const checkbox = document.getElementById(id);
            checkbox.addEventListener('change', function() {
                applyVisibilityFilter();
            });
        });

        // Apply saved theme on page load (before Cytoscape initialization)
        applyTheme(currentTheme);

        // Sidebar resize functionality
        (function() {
            const sidebar = document.getElementById('sidebar');
            const resizeHandle = document.getElementById('resize-handle');
            let isResizing = false;
            let startX = 0;
            let startWidth = 0;

            // Load saved width from localStorage
            const savedWidth = localStorage.getItem('codezoom_sidebar_width');
            if (savedWidth) {
                sidebar.style.width = savedWidth + 'px';
            }

            resizeHandle.addEventListener('mousedown', function(e) {
                isResizing = true;
                startX = e.clientX;
                startWidth = sidebar.offsetWidth;
                resizeHandle.classList.add('dragging');
                document.body.style.cursor = 'col-resize';
                document.body.style.userSelect = 'none';
                e.preventDefault();
            });

            document.addEventListener('mousemove', function(e) {
                if (!isResizing) return;

                const delta = e.clientX - startX;
                const newWidth = startWidth + delta;

                // Respect min/max constraints
                const minWidth = 180;
                const maxWidth = 600;
                const constrainedWidth = Math.max(minWidth, Math.min(maxWidth, newWidth));

                sidebar.style.width = constrainedWidth + 'px';
            });

            document.addEventListener('mouseup', function() {
                if (isResizing) {
                    isResizing = false;
                    resizeHandle.classList.remove('dragging');
                    document.body.style.cursor = '';
                    document.body.style.userSelect = '';

                    // Save width to localStorage
                    localStorage.setItem('codezoom_sidebar_width', sidebar.offsetWidth);
                }
            });
        })();

        // Initialize
        updateUI();
    </script>
</body>
</html>
